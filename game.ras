program game;
//@define CRT_VERSION 1

@ifdef CRT_VERSION
@projectsettings "exomize" "1"
@endif

@ifndef CRT_VERSION
@projectsettings "exomize" "0"
@endif 
@use "system/str"
@use "screen/screen"
@use "compression/compression"

// @use "input/key"


@startblock $1200 "Variables"
var	
	//@define DEBUG 1
	//@define OVERFLOW_CHECK 1
	@define USE_KERNAL 0

	// Charsets
	@define charsetLoc1 $3800
	@define charsetLoc2 $7800
	@define tilesetLoc1 $3000
	@define tilesetLoc2 $7000
	@define spriteLoc1  $2000
	@define spriteLoc2  $4800
	@define tilesetCol  $3a00
	@define logoLoc     $3e00
	@define sfxLoc      $e000
	// Automatically export charsets 
	@export "charsets/charset.flf" "charsets/charset.bin" 60	
 	@export "charsets/tileset.flf" "charsets/tileset.bin" 256	
 	@export "charsets/logo.flf" "charsets/logo.bin" 120
	@export "sprites/spr.flf" "sprites/spr.bin" 4096	
  	charset1: incbin("charsets/charset.bin", @charsetLoc1);
  	charset2: incbin("charsets/charset.bin", @charsetLoc2);
  	tileset1: incbin("charsets/tileset.bin", @tilesetLoc1);
  	tileset2: incbin("charsets/tileset.bin", @tilesetLoc2);
   	logo: incbin("charsets/logo.bin", @logoLoc);
//  	sprite1: incbin("sprites/spr.bin", @spriteLoc1);
  	sprite2: incbin("sprites/spr.bin", @spriteLoc2);
	tilesetColors :  incbin("charsets/tileset_color.bin", @tilesetCol);
@ifndef IS_DEMO 
	musicintro: incsid("music/fizz_intro_2000.sid",2);
//	music: incsid("music/fizz_ingame_e000.sid",2);
  	sfx: incbin("sounds/sounds.prg", @sfxLoc, 2);
@endif
	
	
//	rands: array[256] of byte;


	// Double Buffer
	currentBank: byte=0;
	time: byte=0;
	globaltime: byte=0;
	frameStatus: byte;
	screen: byte;
	countSprite: byte=0;
	cycle: byte;
	needExtraCycle : boolean;
	pos: byte;
	statusCol: byte;
	maxSingleLevels: byte;
	maxMultiLevels: byte;
	// Game	
	@define SCENES_SIZE 1
	@define DIMX 20
	@define DIMY 12
	@define DIMZ 4
	@define MAX_OBJECTS 240
	@define MAX_CONTROLS 2
	@define MAX_LASERS 12
	@define MAX_LASER_SIZE 30
	@define MAX_ACTORS 32
	@define MAX_LEV_STRINGS 8
	@define ACTOR_LENGTH 8

	@define DIMTILES 240
	@define DIMANIMS 14
	@define Z_BACK2 3
	@define Z_BACK1 2
	@define Z_MAIN 1
	@define Z_FRONT 0
	@define UNKNOWN $FF
	@define DOWN 7
	@define UP 1
	@define LEFT 3
	@define RIGHT 5
	@define SHIFT_DOWN 4
	@define SHIFT_UP 5
	@define SHIFT_LEFT 6
	@define SHIFT_RIGHT 7
	@define DOWN_LEFT 6
	@define DOWN_RIGHT 8
	@define UP_LEFT 0
	@define UP_RIGHT 2
	@define STOP 12
	@define AREA_OUT $FF
	@define AREA_DOWN 0
	@define AREA_UP 1
	@define AREA_LEFT 2
	@define AREA_RIGHT 3
	@define AREA_CENTER 4
	@define LASER_STEP 4
	@define TURN_RIGHT 1
	@define TURN_LEFT 2
	@define TURN_THROUGH  3
	@define ON 1
	@define OFF $FF
	@define LASER_TYPE_USER 10 
	@define REND_TYPE_TILE 0
	@define REND_TYPE_SPRITE 1
	@define REND_TYPE_BYTE 2
	
	@define ANIM_MODE_FIX 0
	@define ANIM_MODE_LR 1
	@define ANIM_MODE_LR_REPEAT 2
	@define ANIM_MODE_MANUAL 3
	
	@define ANIM_WALK_L 0
	@define ANIM_WALK_R 1
	@define ANIM_STAND 2
	@define ANIM_SWIM_L 3
	@define ANIM_SWIM_R 4
	@define ANIM_CLIMB 5
	@define ANIM_ROBE 6
	@define ANIM_PORTAL 7
	@define ANIM_SWITCH_ON 8
	@define ANIM_SWITCH_OFF 9
	@define ANIM_DOOR_ON 10
	@define ANIM_DOOR_OFF 11
	@define ANIM_EXIT_ON 12
	@define ANIM_EXIT_OFF 13
	
	@define SOUND_TRANSPORT 18	// ->19
	@define SOUND_DAMAGE 7
	@define SOUND_LASER 11
	@define SOUND_JUMP 3
	@define SOUND_STEP 8
	@define SOUND_SWIM 9 // ->1
	@define SOUND_GRAV_ACTIVATE 10 // ->15
	@define SOUND_SWITCH_ON 4 // ->16
	@define SOUND_SWITCH_OFF 5
	@define SOUND_FALL_CRASH 17
	@define SOUND_FALL 2
	@define SOUND_SHIFT 13
	@define SOUND_LADDER 0
	@define SOUND_SCENE_START 6
	@define SOUND_END 16
	@define SOUND_PLAYER_CHANGE 12
	@define SOUND_PORTAL_ACTIVATE 20 
	@define SOUND_PORTAL 21 
	@define SOUND_EXIT 22
	@define SOUND_EXIT_CLOSE 23 
	
	
	collAreaUp: array[9] of byte = (8,7,6,5,4,3,2,1,0);
	collAreaLeft: array[9] of byte = (2,5,8,1,4,7,0,3,6);
	collAreaRight: array[9] of byte = (6,3,0,7,4,1,8,5,2);

	shiftAreaDownX: array[9] of byte = (-1, 0, 1 , -1, 0, 1, -1, 0, 1);
	shiftAreaUpX: array[9] of byte = (1, 0, -1, 1, 0, -1, 1, 0, -1);
	shiftAreaLeftX: array[9] of byte = (1, 1, 1, 0, 0, 0, -1, -1, -1);
	shiftAreaRightX: array[9] of byte = (-1, -1, -1,0, 0, 0, 1, 1, 1);

	shiftAreaDownY: array[9] of byte = (-1, -1, -1, 0, 0, 0, 1, 1, 1);
	shiftAreaUpY: array[9] of byte = ( 1, 1, 1 , 0, 0, 0, -1, -1, -1);
	shiftAreaLeftY: array[9] of byte = ( -1, 0, 1, -1, 0, 1, -1, 0, 1);
	shiftAreaRightY: array[9] of byte = ( 1, 0, -1,  1, 0, -1, 1, 0, -1);

	ystart: array[12] of byte = ( 0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220 );
	
	tempPointer: pointer of byte;
	
	@define STATE_MENU 0
	@define STATE_INIT 1
 	@define STATE_OPEN_SCENE 2
	@define STATE_PLAY 3
	@define STATE_CLOSE_SCENE 5
	@define STATE_MENU_INPUT 6
	@define STATE_OPEN_SCENE_INPUT 7
	@define STATE_OPEN_SCENE_REQUEST 8
	
	@define MODE_SINGLE 0
	@define MODE_SINGLE_2CHAR 1
	@define MODE_COOP 2
		
	@define COMP_PHYSICS_0          %00000001
	@define COMP_COLLIDE_ABLE_0     %00000010
	@define COMP_SHIFT_PLATTFORM_0  %00000100	
	@define COMP_DESTROY_COLLIDE_0  %00001000
 	@define COMP_ERASE_ABLE_0       %00010000
 	@define COMP_WATER_0            %00100000
	@define COMP_ANIMATION_0	    %01000000	
	@define COMP_CONTROL_0		    %10000000
    @define COMP_PUSHPULL_1 	    %00000001
    @define COMP_CLIMB_ABLE_1 	    %00000010
    @define COMP_ROBE_ABLE_1 	    %00000100
    @define COMP_FLOATER_1 		    %00001000
	@define COMP_PORTAL_1 		    %00010000
	@define COMP_GRAVPAD_1		    %00100000
	@define COMP_LASER_1		   	%01000000
	@define COMP_MIRROR_1		    %10000000
	@define COMP_DESTROY_ABLE_2     %00000001
	@define COMP_LASERBEAN_2		   %00000010
	@define COMP_LASERTRANS_ABLE_2  %00000100
	@define COMP_LASERONCE_2        %00001000
	@define COMP_PORTAL_ACTIVATE_2  %00010000
	@define COMP_FONTAINE_2         %00100000
	@define COMP_SWITCH_2           %01000000
	@define COMP_DOOR_2             %10000000
	@define COMP_EXIT_3             %00000001
	@define COMP_WAYPOINT_3         %00000010
	@define COMP_BULK_PHYS_3		   %00000100
 	// https://www.aivosto.com/articles/petscii.pdf
 	@define LEV_CHARACTER $40  //@
 	@define LEV_CHARACTER2 $25 //%
	@define LEV_BRICK $61 // a
	@define LEV_STONE $62 // b
	@define LEV_SAND $73 // s
	@define LEV_WATER $3d // =
	@define LEV_WATER_UP $27 // '
	@define LEV_WATER_DOWN $26 // &
	@define LEV_WATER_LEFT $7b // ?  
	@define LEV_WATER_RIGHT $7d // ?
	@define LEV_SHIFT_DOWN $59 // Y
	@define LEV_SHIFT_UP $5E // ^
	@define LEV_SHIFT_LEFT $3C // <
	@define LEV_SHIFT_RIGHT $3E // >
	@define LEV_LADDER $68 // h
	@define LEV_ROBE_DOWN $5f  // _ 
	@define LEV_ROBE_UP $2d // -
	@define LEV_ROBE_LEFT $21 // !
	@define LEV_ROBE_RIGHT $7C // |
	@define LEV_PORTAL $6F // o
	@define LEV_GRAVPAD_DOWN $32 // 2
	@define LEV_GRAVPAD_UP $38 // 8
	@define LEV_GRAVPAD_LEFT $34 // 4
	@define LEV_GRAVPAD_RIGHT $36 // 6
	@define LEV_MIRROR_LEFT $6e // n 
	@define LEV_MIRROR_RIGHT $6d // m
	@define LEV_GLASS $67 // g
	@define LEV_LASER_TRANSPORT $74 // t
	@define LEV_PUSH_BOX $64 // d 
	@define LEV_PULL_BOX $65 // e
	@define LEV_PORTAL_ACTIVATE  $63 // c
	@define LEV_FONTAINE_DOWN $5b // [
	@define LEV_FONTAINE_LEFT $28 // (
	@define LEV_FONTAINE_RIGHT $29 // )
	@define LEV_FONTAINE_UP $5d // ]
	@define LEV_CANNON_DOWN $31 // 1
	@define LEV_CANNON_UP $39 // 9
	@define LEV_CANNON_LEFT $37 // 7
	@define LEV_CANNON_RIGHT $33 // 3
	@define LEV_SWITCH_MANUAL $72 // r
	@define LEV_DOOR $78 // x
	@define LEV_EXIT $58 // X
	@define LEV_WAYPOINT $2E // .
	@define LEV_BLOCK $66 // f

	@define CTRL_STATE_WALK 0
	@define CTRL_STATE_CLIMB 1
	@define CTRL_STATE_ROBE 2
	@define CTRL_STATE_SWIM 3
	@define CTRL_STATE_JUMP 4
	@define CTRL_STATE_DESTROY 5
	@define CTRL_STATE_RETRY 6
	@define CTRL_STATE_EXITED 7
	@define CTRL_STATE_DIE 8

	@define EVENT_INIT_LEVEL 0
	@define EVENT_SWITCH_ON 1
	@define EVENT_SWITCH_OFF 2
	@define EVENT_WAYPOINT_ENTER 3
	@define EVENT_WAYPOINT_LEAVE 4
	
	@define ACTION_DOOR_OPEN 1
	@define ACTION_DOOR_CLOSE 2
	@define ACTION_EXIT_OPEN 3
	@define ACTION_EXIT_CLOSE 4
	@define ACTION_PRINT_TEXT 5
	@define ACTION_CLEAR_TEXT 6
	@define ACTION_LASERCANNON_ON 7
	@define ACTION_LASERCANNON_OFF 8
	@define ACTION_FONTAINE_ON 9
	@define ACTION_FONTAINE_OFF 10
	@define ACTION_SET_GRAV 11
	@define ACTION_SWITCH_ON 12
	@define ACTION_SWITCH_OFF 13
	@define ACTION_SET_GRAV_BULK 14
	
	
	@define DO_ACTIVATE_SWITCH_START 17
	txtDoActiveSwitch: string=("SWITCH");
	@define ACTIVATE_SWITCH_START 12
	txtActiveSwitch:   string=("SWITCH ACTIVATED");
	@define DEACTIVATE_SWITCH_START 11
	txtDeactiveSwitch: string=("SWITCH DEACTIVATED");
	@define EXIT_CLOSED_START 16
    txtExitClosed: string=("EXIT CLOSED");
	@define CHAR_SWAP_RED 15
	txtCharSwapRed: string=("ACTIVE: RED");
	@define CHAR_SWAP_GREEN 12
	txtCharSwapGreen: string=("ACTIVE: GREEN");
	@define PLAYER_EXIT 12
	txtPlayerExit: string=("PLAYER EXITED");
    txtSelectGameMode: string=("SELECT GAME MODE:"); 
    txtSinglePlayer: string=("SINGLE PLAYER");
    txtSinglePlayer2Chars: string=("SINGLE PLAYER TWO CHARACTERS");
    txtCoop: string=("TWO PLAYER CO-OP"); 
    txtSingleStart: string=("SINGLE PLAYER START LEVEL:");
    txtCoopStart: string=("CO-OP START LEVEL:");
    txtAuthor: string=("CODE: ANDY DAUMANN");
    txtMusican: string=("MUSIC: PICRARD");
	
	countObjects: byte;
	deletedObjects: Array[@MAX_OBJECTS] of byte;
	dynObjectList : Array[@MAX_OBJECTS] of byte;
	animObjectList : Array[@MAX_OBJECTS] of byte;
	countDyn: byte;
	countAnim: byte;
	countLasers: byte;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	portals: Array [2] of byte;
	lastPortal: byte;
	state: byte;
	sp: pointer;
	dp: pointer;
	textTimer: byte;
	levelSingle: byte;
	levelCoop: byte;
	nextLevel: byte;
	gameMode: byte;
	activeChar: byte;
	retryPressed: byte;
	menuItem: byte = 0;
	soundId: byte;
	soundTimer: byte;
	initSound: byte;
	freq: byte;
	voice: byte;
	musicStr: string = ("T1");
	
	@define ANIM_CONSIDER_GRAV_IGNORE 0
	@define ANIM_CONSIDER_GRAV_FULL 1
//	@define ANIM_CONSIDER_GRAV_HALF 2
	
	animObject = class
		animSeq: array[4] of byte;
		considerGravity: byte;
		size: byte;
		speed: byte;
		mode: byte;
	end;
	animList : Array[@DIMANIMS] of animObject;

	actorObject = record
		event: byte;
		senderId: byte;
		action: byte;
		receiverId: byte;
		param0, param1, param2, param3: byte;
	end;

	controlObject = record
		controlJumpStep: byte;
		controlState: byte;
		controlFollowKeyRight, controlFollowKeyLeft: byte;
		b_controlPressLeft, b_controlPressRight, b_controlPressUp, b_controlPressDown, b_controlPressAction: byte;
		b_firePressed: byte;
		controlLastPortal: byte;
		b_waitRelease, b_release: byte;
		waypointId: byte;
		lastWaypointId: byte;
		controlCollideLaserTag: byte;
		b_fallDown: byte;
	end;
	
	laserObject = record
		laserDir: byte;
		lastLaserDir: byte;
 		laserLastTransportAble: byte;
 		laserType : byte;
		currentLaser: byte; 		
	end;
	controlList : Array[@MAX_CONTROLS] of controlObject;
	actorList : Array[@MAX_ACTORS] of actorObject;
	laserList : Array[@MAX_LASERS] of laserObject;

@endblock

/*
@ifdef IS_DEMO
	@startblock "$08FD" "Global"
	maxSingle, maxMulti: byte;
	@endblock
@endif
*/

@startblock $1c00 "level"

    lev: string = ("x {aaaaaa  a  a  aaa  ^a aa  a  aa    aa6 e  aaa  aa   d  aaa a6    [12    ^ ^Yaa  %  o   ^      ^Yaa&     ^         ^Yaa&    ^          ^Yaa&            h     a& 4------====hh   aa&m   n   b@   = f aaX  x===ss rs8 h o aaaaaaaaaaaaaaa>>aaaa");
										  //event, action, senderpos, receiverpos, p1, p2, p3, p48
	levActor: Array[@MAX_ACTORS * @ACTOR_LENGTH] of byte = (1, 1 ,211 , 204, $FF, $FF, $FF, $FF,
												            2, 2 ,211 , 204, $FF, $FF, $FF, $FF,	 
												 		    1, 1, 211,  0,   $FF, $FF, $FF, $FF,
												 			2, 2, 211,  0, $FF, $FF, $FF, $FF,
												 			1, 3, 211, 201,$FF, $FF, $FF, $FF,
												 			2, 4, 211, 201,$FF, $FF, $FF, $FF,
												 			3, 5, 211, $FF, $00, 17, 10, $FF,
												 			4, 6, 211, $FF, $FF, $FF, $FF, $FF,
												 			0, 5, $FF, $FF, $00, 17, 10, $FF,
												 			3, 5, 70, $FF, $00, 17, 10, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF, 	
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF); 	

	levBothMustComplete: boolean = true;
	levStrings: Array[@MAX_LEV_STRINGS] of string = ("WELCOME","aa","bb","cc","dd","ee","ff","gg");
@endblock

@startblock $ea00 "Objects"

	gobject = record
		component0, component1, component2, component3: byte;
		
		// TransformTile
		transX, transY, transZ: byte;
	
		// Render
		rendTilePos: byte;
		rendType: byte;
		
		// Physics
		physGravity: byte;
		b_physFallDown: byte;
		b_physRollLeftRight: byte;

		// ShiftPlattform
		shiftDir: byte;
		
		// Control
		controlId: byte;
		moves: byte;
						
		// Animation
		animId: byte;
		animPos: byte;
		animFinish: byte;

		// Portal
		portalFireExitDir: byte;
		
		// Laser, Fontaine
		laserEmitId: byte;
 		laserTag: byte;
 		
		// Mirror
 		mirrorTurn: byte;
		
		// PushPull  , Door, Exit, Switch
		onOff: byte;
	end;
	objectList : Array[@MAX_OBJECTS] of gobject;
@endblock

@ifdef CRT_VERSION
@startblock $1000 "CodeCrt"

procedure LoadMusicFromCrt();
begin
	setmemoryconfig(1,1,1);
	Poke(^$DE00,0,$0F);
    Compression::Decompress($8000, $2000);	
	setmemoryconfig(1,0,0);
end;

procedure LoadLevelFromCrt(lev: byte, isSingle: boolean);
var
	bank, i : byte;
begin
	sp := CreatePointer($80, 00);
	if(isSingle = true) then begin
		if(lev <= $1f) then 
			bank := $0B
		else begin 
			bank := $0C;
			lev := lev - $20;
		end;
		if(lev <> 0) then begin
			
			for i := 0 to lev do
			begin
				sp := sp + $100;
			end;		
		end;
	end
	else begin 
		if(lev <= $13) then 
			bank := $0D 
		else begin 
			bank := $0E;
			lev := lev - $14;
		end;
		if(lev <> 0) then begin
			for i := 0 to lev do
			begin
				sp := sp + $80;
				sp := sp + $100;
			end;		
		end;
	end;
	setmemoryconfig(1,1,1);
	Poke(^$DE00,0,bank);
    Compression::Decompress(sp, $1bfe);	
	setmemoryconfig(1,0,0);
end;
@endblock
@endif

@startblock $5800 "Code"


procedure InitSprites();
var
	i:byte;
begin
	// Set all sprites to be multicolor
	sprite_multicolor:=$ff;
	// Set common sprite multicolor #1 
	sprite_multicolor_reg1:=dark_grey;
	// Set  common sprite multicolor #2 
	sprite_multicolor_reg2:=white;
	for i := 0 to 8 do begin 
		sprite_color[i]:=light_red;
		SpritePos(0,0,i);
	end;
	sprite_color[1]:=green;
	// Turn on sprite 0 (or @useSprite)
	sprite_bitmask := $FF;
//	togglebit(sprite_bitmask,0,1);
end;

procedure PrintText(x: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 40) then SCREEN_BG_COL:=BLUE;
	@ENDIF
	@IFNDEF DEBUG
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
		screenmemory[0]:=$1c;
		screenmemory[39]:=$1d;
		moveto(x,24,screen);
		printstring(sp,0,40);
		statusCol := @WHITE;
	@ENDIF		
end;

procedure ClearText();
begin
	@IFNDEF DEBUG
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
		screenmemory[0]:=$1c;
		screenmemory[39]:=$1d;
		statusCol := @DARK_GREY;
	@ENDIF
end;

procedure SwapActiveChar();
begin
	textTimer := 20;
	if(activeChar = 0 and controlList[1].controlState <> @CTRL_STATE_EXITED) then begin 
		activeChar := 1;
		sp :=  #txtCharSwapGreen;
		PrintText(@CHAR_SWAP_GREEN);
	end 
	else if(activeChar = 1 and controlList[0].controlState <> @CTRL_STATE_EXITED) then begin 
		activeChar := 0;
		sp :=  #txtCharSwapRed;
		PrintText(@CHAR_SWAP_RED);
	end;				
end;

	
procedure InitLevel();
var 
	i : integer;
	levStr: string = "XFF";	
begin
	state := @STATE_PLAY;
	countObjects := 0;
	countDyn := 0;
	countAnim := 0;
	textTimer := 0;
	countSprite := 0;
	countLasers := 0;
	retryPressed := false;
	activeChar := 1;
	statusCol := @DARK_GREY;

	levStr[2] := 0;
	for i:= $EA00 to $FFF0 do begin
		sp := int2ptr(i);
		sp[0] := $FF;
	end;
	
	
	if(gameMode = @MODE_SINGLE) then begin
//		if(nextLevel <> levelSingle) then begin
			levelSingle := nextLevel;
			levStr[0] := 'S';
			str::itoa(levelSingle, #levStr+1, 16);
			
			@ifdef CRT_VERSION 
			LoadLevelFromCrt(levelSingle, true);
			@endif
			
			@ifdef IS_DEMO 
			asm(
"
	ldx #<localVariable_InitLevel_levStr
	ldy #>localVariable_InitLevel_levStr
	jsr $200
");
			@endif
//		end;
	end
	else begin
		if(gameMode = @MODE_SINGLE_2CHAR) then SwapActiveChar();

//		if(nextLevel <> levelCoop) then begin
			levelCoop := nextLevel;
			levStr[0] := 'M';
			str::itoa(levelCoop, #levStr+1, 16);
			@ifdef CRT_VERSION 
			LoadLevelFromCrt(levelCoop, false);
			@endif
			@ifdef IS_DEMO 
			asm(
"
	ldx #<localVariable_InitLevel_levStr
	ldy #>localVariable_InitLevel_levStr
	jsr $200
");
			
			@endif
//		end;
	end;
end;


procedure SetNextLevel();
begin 
	if(gameMode = @MODE_SINGLE) then begin
		if(levelSingle + 1 >= maxSingleLevels) then nextLevel := 0
		else begin
			nextLevel := levelSingle + 1;
		end;
	end
	else begin
		if(levelCoop +1 >= maxMultiLevels) then nextLevel := 0
		else begin
			nextLevel := levelCoop + 1;
		end;
	end;
end;

procedure IncLevel(mode: byte);
begin 
	if(mode = @MODE_SINGLE) then begin
		if(levelSingle < maxSingleLevels - 1) then inc(levelSingle);
	end
	else begin
		if(levelCoop < maxMultiLevels - 1) then inc(levelCoop);
	end;
end;

procedure DecLevel(mode: byte);
begin 
	if(mode = @MODE_SINGLE) then begin
		if(levelSingle > 0) then dec(levelSingle);
	end
	else begin
		if(levelCoop > 0) then dec(levelCoop);
	end;
end;


procedure InitGame(levSingle, levCoop: byte, mode: byte);
begin
	levelSingle := levSingle;
	levelCoop := levCoop;
	gameMode := mode;
	if(gameMode = @MODE_SINGLE) then nextLevel := levSingle else nextLevel := levCoop;
	menuItem := 0;
	cycle := 0;
	needExtraCycle := false;
//	InitRand();
end;


procedure print2x2block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c+1;
	screenmemory[40]:=c+40;
	screenmemory[41]:=c+41;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c+1]+8;
	screenmemory[40]:=tilesetColors[c+40]+8;;
	screenmemory[41]:=tilesetColors[c+41]+8;;
end;

procedure print1x1block(x,y,c: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COL:=BROWN;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	moveto(x*2,y*2,screen);
	screenmemory[0]:=c;
	screenmemory[1]:=c;
	screenmemory[40]:=c;
	screenmemory[41]:=c;

	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c]+8;
	screenmemory[40]:=tilesetColors[c]+8;;
	screenmemory[41]:=tilesetColors[c]+8;;
end;

procedure CycleWater();
var
	waterStep : byte;
begin	
	waterStep := mod(globaltime,4);
		 
	sp := @tilesetLoc1 + (240 + waterStep) * 8;
	dp := @tilesetLoc1 + 22*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 22*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (243 - waterStep) * 8;
	dp := @tilesetLoc1 + 23*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 23*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (244 + waterStep) * 8;
	dp := @tilesetLoc1 + 62*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 62*8;
	MemCpyFast(sp, 0, dp,8);
	
	sp := @tilesetLoc1 + (247 - waterStep) * 8;
	dp := @tilesetLoc1 + 63*8;
	MemCpyFast(sp, 0, dp,8);
	dp := @tilesetLoc2 + 63*8;
	MemCpyFast(sp, 0, dp,8);
end;

procedure PrintSprite(x: byte, y: byte, spriteLoc: byte, num: byte);
var
	xs: integer;
	ys: byte;
	ns: byte;
begin
	xs := 24 + (x shl 4);
	ys := 50 + (y shl 4);
	if(currentBank = 0) then begin
		ns := spriteLoc + $80;
		SetSpriteLoc(num, ns, 0);
	end
	else begin
		ns := spriteLoc + $20;
		SetSpriteLoc(num, ns, 1);
	end;
	SpritePos(xs,ys,num);
end;

procedure print2x2blockEmpty(x,y:byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= @DIMX or y >= @DIMY) then SCREEN_BG_COL:=GREY;
	@ENDIF
	moveto(x*2,y*2,screen);
	screenmemory[0]:=255;
	screenmemory[1]:=255;
	screenmemory[40]:=255;
	screenmemory[41]:=255;
end;

procedure GetZLayerPointer(z: byte);
begin
	case z of
		@Z_BACK2: tempPointer := #mapback2;
		@Z_BACK1: tempPointer := #mapback1;
		@Z_MAIN: tempPointer := #mapmain;
		@Z_FRONT: tempPointer := #mapfront;
	end;
end;

function PaintPosAnim(t: byte, considerAnimation: boolean) : byte;
var
	x,y: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
	
begin
 	animId := objectList[t].animId;
	pa := #animList[animId];
 	if(considerAnimation = true and (objectList[t].component0 & @COMP_ANIMATION_0 = @COMP_ANIMATION_0)) then begin
		if(pa.considerGravity = @ANIM_CONSIDER_GRAV_IGNORE) then shiftAnim := 0
		else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_FULL) then begin
			gravity := @DOWN;
			if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
			if(gravity = @DOWN) then shiftAnim := 0
			else if(gravity = @UP) then shiftAnim := 1
			else if(gravity = @RIGHT) then shiftAnim := 2
			else if(gravity = @LEFT) then shiftAnim := 3;
		end;
/*			else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_HALF) then begin
			gravity := @DOWN;
			if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
			if(gravity = @UP) then shiftAnim := 1
			else if(gravity = @RIGHT) then shiftAnim := 0
			else if(gravity = @LEFT) then shiftAnim := 1;
		end;*/
		currentTile := pa.animSeq[objectList[t].animPos];
		currentTile := currentTile + shiftAnim;
	
	if(pa.mode = @ANIM_MODE_FIX) then objectList[t].animPos := 0
		else if(pa.mode = @ANIM_MODE_LR and objectList[t].animFinish = false) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := pa.size - 1;
				objectList[t].animFinish := true;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end
		else if(pa.mode = @ANIM_MODE_LR_REPEAT) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := 0;
				objectList[t].animFinish := false;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end;				
	end
	else currentTile := objectList[t].rendTilePos;
	PaintPosAnim := currentTile;
end;

procedure PaintPos(pos: byte, considerAnimation: boolean);
var
	x,y: byte;
	t, tHide: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=BROWN;
	@ENDIF
	
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	t := $FF;
	currentTile := $FF;
	hideSprite:= false;

 	if(mapfront[pos] <> 255) then begin
	 	t := mapfront[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
	 	hideSprite := true;
 	end
 	else if(mapmain[pos] <> 255) then begin
	 	t := mapmain[pos];
	 	currentTile := PaintPosAnim(t, true);
 	end
 	else if(mapback1[pos] <> 255) then begin
	 	t := mapback1[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end
	else if(mapback2[pos] <> 255) then begin
	 	t := mapback2[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end;
	
	if(t <> $FF) then begin
		if(hideSprite = true) then begin
			tHide := mapmain[pos];
			if(tHide <> $FF and objectList[tHide].rendType = @REND_TYPE_SPRITE) then
			 	PrintSprite(0,@DIMY+1,0,objectList[tHide].controlId)
		end;
	 	if(objectList[t].rendType = @REND_TYPE_SPRITE and hideSprite = false) then
		 	PrintSprite(x,y,currentTile,objectList[t].controlId)
	 	else if(objectList[t].rendType = @REND_TYPE_TILE) then 
	 		print2x2block(x,y,currentTile)
	 	else 
	 		print1x1block(x,y,currentTile);
	end
	else print2x2blockEmpty(x,y);
end;

function ConvertShift(gravity: byte, pos: byte) : integer;
var 
    ret: integer;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= 9) then SCREEN_BG_COL:=RED;
		if(gravity = $FF) then SCREEN_BG_COL:=RED;
	@ENDIF
	if(gravity = @DOWN) then ret := CreateInteger(shiftAreaDownX[pos],shiftAreaDownY[pos])
 	else if(gravity = @UP) then ret := CreateInteger(shiftAreaUpX[pos],shiftAreaUpY[pos])
 	else if(gravity = @LEFT) then ret := CreateInteger(shiftAreaLeftX[pos],shiftAreaLeftY[pos])
 	else if(gravity = @RIGHT) then ret := CreateInteger(shiftAreaRightX[pos],shiftAreaRightY[pos]);
    ConvertShift := ret; 	
end;


function CalcPosition(startx,starty, pos: byte) : integer;
var
	destx, desty: byte;
begin
	destx := startx + shiftAreaDownX[pos];
	desty := starty + shiftAreaDownY[pos];
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPosition := CreateInteger(destx, desty); 
end;


function CalcPositionMapPos(startx,starty, pos: byte) : byte;
var 
	npos: integer;
begin
	npos := CalcPosition(startx,starty, pos);
	CalcPositionMapPos := hi(npos) + ystart[lo(npos)];
end;

function GetObjectByPosFilterComp(x: byte, y: byte, z: byte, comp: byte, compIdx: byte) : byte;
var
	mapPos, colId, ret, val: byte;
begin
	GetZLayerPointer(z);
	ret := $FF;
	mapPos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(mapPos >= @DIMTILES) then SCREEN_BG_COL:=LIGHT_RED;
	@ENDIF

	colId := tempPointer[mapPos];
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;

	GetObjectByPosFilterComp := ret;
end;

function GetObjArea(id: byte, z: byte, pos:byte, comp: byte, compIdx: byte, b_norm: byte) : byte;
var
	gravity: byte;
	mapPos, colId, ret, val, gpos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(id >= @MAX_OBJECTS) then SCREEN_BG_COL:=LIGHT_GREY;
	@ENDIF
	gravity := @DOWN;
	if(b_norm = false) then begin
		if((objectList[id].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[id].physGravity;

		if(objectList[id].physGravity = @DOWN) then gpos := pos
		else if(objectList[id].physGravity = @UP) then gpos := collAreaUp[pos] 
		else if(objectList[id].physGravity = @LEFT) then gpos := collAreaLeft[pos] 
		else if(objectList[id].physGravity = @RIGHT) then gpos := collAreaRight[pos]
	end
	else gpos := pos;

	GetZLayerPointer(z);

	mapPos := CalcPositionMapPos(objectList[id].transX, objectList[id].transY, gpos);
	colId := tempPointer[mapPos];
	ret := $FF;
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;
	GetObjArea := ret;
end;

function CalcPositionX(startx,offsetx: byte) : byte;
var
	destx: byte;
begin
	destx := startx + offsetx;
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	CalcPositionX := destx;
end;

function CalcPositionY(starty,offsety: byte) : byte;
var
	desty: byte;
begin
	desty := starty + offsety;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPositionY := desty;
end;

procedure ChangeMapItem(id: byte, oldx: byte, oldy: byte, x: byte, y: byte, z:byte);
var
	oldpos: byte;
	pos: byte;
begin
	oldpos := oldx + ystart[oldy];
	pos := x + ystart[y];
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
		if(oldpos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	tempPointer[oldpos] := $FF;
	tempPointer[pos] := id;
	// ##
	PaintPos(oldpos, true);
	PaintPos(pos, true);
end;

procedure UpdateMapItem(id: byte, x: byte, y: byte);
var
	oldpos: byte;
	pos: byte;
begin
	pos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	PaintPos(pos, true);
end;

procedure SetPos(i: byte,oldx:byte, oldy:byte, x: byte, y: byte, z: byte);
var
	pos: byte;
	waypointId, lastWaypointId, controlId: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(i >= @MAX_OBJECTS) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	pos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	controlId := objectList[i].controlId;
	inc(objectList[i].moves); 

	if(controlId <> $FF) then begin
		waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(waypointId = $FF) then
			waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(lastWaypointId = $FF) then
			lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		controlList[controlId].waypointId := waypointId;
		controlList[controlId].lastWaypointId := lastWaypointId;
	end;
	
	ChangeMapItem(i, oldx, oldy, x, y, z);
	objectList[i].transX := x;
	objectList[i].transY := y;
end;

procedure SetZLayer(id: byte, oldz: byte, newz: byte);
var
	pos: byte;
begin
	pos := objectList[id].transX + ystart[objectList[id].transY];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COL:=CYAN;
	@ENDIF
	inc(objectList[id].moves); 
	GetZLayerPointer(oldz);
	tempPointer[pos] := $FF;
	GetZLayerPointer(newz);
	tempPointer[pos] := id;
	objectList[id].transZ := newz;
	PaintPos(pos, true);
end;

procedure AddMapItem(Id: byte, x: byte, y: byte, z:byte);
var
	pos: byte;
begin
	pos := x + ystart[y];
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COL:=YELLOW;
	@ENDIF
	
	tempPointer[pos] := Id;
end;

procedure ClearMap();
var 
	m: byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
	portals[0] := $FF;
	portals[1] := $FF;
end;

procedure AddDynItem(i: byte);
begin
	dynObjectList[countDyn] := i;
	inc(countDyn);
end;

procedure AddAnimItem(i: byte);
begin
	animObjectList[countAnim] := i;
	inc(countAnim);
end;
function GetId() : byte;
var
	ret: byte;
begin
    if (countObjects = @MAX_OBJECTS) then	 begin 
		ret := $FF;
	end
    	else begin	
		inc(countObjects);
		ret := deletedObjects[@MAX_OBJECTS - 1 - countObjects];
	end;

	GetId := ret;
end;

function GetLaserEmitId() : byte;
var
	ret: byte;
begin
    if (countLasers = @MAX_LASERS) then	 ret := $FF
    	else begin	
		inc(countLasers);
		ret := countLasers;
	end;

	GetLaserEmitId := ret;
end;

procedure PaintFull();
var
	i: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i, false);
	end;
end;

procedure DeleteMapItem(id: byte, x: byte, y: byte, z:byte);
var	
	pos: byte;
begin
	pos := x + ystart[y];	
	GetZLayerPointer(z); 
	tempPointer[pos] := 255;
end;

procedure DeleteDynObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countDyn - 1 and found = false)  do
	begin
		if(dynObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countDyn); 
		for j:= i to countDyn do begin
			dynObjectList[j] := dynObjectList[j+1];
		end;
	end;
end;

procedure DeleteAnimObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countAnim - 1 and found = false) do
	begin
		if(animObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countAnim); 
		for j:= i to countAnim do begin
			animObjectList[j] := animObjectList[j+1];
		end;
	end;
end;
	
procedure DeletePos(id: byte, isDyn, isAnim: byte);
var
	x,y: byte;
begin
	if(countObjects > 0) then begin
		deletedObjects[@MAX_OBJECTS - 1 - countObjects] := id;
		dec(countObjects);
		DeleteMapItem(id, objectList[id].transX, objectList[id].transY, objectList[id].transZ);
		if(isDyn = true) then begin
			DeleteDynObject(id); 
			PaintPos(objectList[id].transX + ystart[objectList[id].transY], true);
			if(objectList[id].rendType = @REND_TYPE_SPRITE) then
			 	PrintSprite(0,@DIMY+1,0,objectList[id].controlId);
		end;

		if(isAnim = true) then DeleteAnimObject(id);
		PaintPos(objectList[id].transX + ystart[objectList[id].transY], true);
	end; 
end;	

procedure SwitchBank();
begin
	if (currentBank = 0) then 
	begin
		SetBank(VIC_BANK1);
		setcharsetlocation(@tilesetLoc2);
		screen := hi(screen_char_loc);
		currentBank := 1;
	end
	else 
	begin
		SetBank(VIC_BANK0);
		setcharsetlocation(@tilesetLoc1);
		screen := hi(screen_char_loc2);
		currentBank := 0;
	end;

end;

procedure CycleAnimation(id: byte);
var
	animId: byte;
	pa: pointer of animObject;

begin
 	animId := objectList[id].animId;
	pa := #animList[animId];
	if(objectList[id].animPos = pa.size - 1) then begin
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end
	else if(mod(globaltime, pa.speed) = 0) then inc(objectList[id].animPos);
end;

procedure SwitchAnimation(id: byte, anim: byte); 
begin
	if(objectList[id].animId <> anim) then begin
		objectList[id].animId := anim;
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end;
end;

procedure ClearLaserWithTag(tag: byte);
var
	i,c: byte;
	d: byte;
begin
	for i:= 0 to @DIMTILES do begin
		
		c := mapfront[i];
		if(c <> $FF and objectList[c].laserTag = tag) then begin
			if(objectList[c].component2 & @COMP_LASERBEAN_2 = @COMP_LASERBEAN_2) then begin 
				DeletePos(c, false, false);
			end;
		end;
/*		c := mapback2[i];
		if(c <> $FF and (objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
		*/
	end;
end;


procedure ClearAllLaser();
var
	i,c: byte;
	d: byte;
begin
	for i:= 0 to @DIMTILES do begin
		
		c := mapfront[i];
		if(c <> $FF and objectList[c].laserTag <> $FF) then begin
			if(objectList[c].component2 & @COMP_LASERBEAN_2 = @COMP_LASERBEAN_2 or objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0) then begin 
				DeletePos(c, false, false);
			end;
		end;
		c := mapback2[i];
		if(c <> $FF and (objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
	end;
end;

procedure DirectFire(id: byte, xpos, ypos: byte, xdir, ydir: byte, bomb: boolean);
var
	laserEmitId: byte;
	laserId: byte;
	collideId, floaterId: byte;
	collide: boolean;
	laserx, lasery, lastx, lasty: byte;
	countLaser: byte;
	dir: byte;
	tileUp, tileDown, tileLeft, tileRight, z, rendType, comp0, comp2: byte;
begin	
	if(objectList[id].onOff = @ON) then begin
		laserEmitId := objectList[id].laserEmitId;
		if(bomb = true) then begin
			tileLeft := 90;
			tileRight := 90;
			tileUp := 88;
			tileDown := 88;
			z := @Z_FRONT;
			rendType := @REND_TYPE_TILE;
			comp0 := $00 | @COMP_COLLIDE_ABLE_0;
			comp2 := $00 | @COMP_LASERBEAN_2;
		end
		else begin
			tileLeft := 62;
			tileRight := 63;
			tileUp := 23;
			tileDown := 22;
			z:= @Z_BACK2;
			rendType := @REND_TYPE_BYTE;
			comp0 := $00 | @COMP_COLLIDE_ABLE_0 | @COMP_WATER_0;
			comp2 := $00;
		end;
			
		collide := false;
		lastx := xpos;
		lasty := ypos;
		laserx := CalcPositionX(xpos, xdir);
		lasery := CalcPositionY(ypos, ydir);
		countLaser := 0;
		collideId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_COLLIDE_ABLE_0, 0);
		floaterId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_FLOATER_1, 1);
		if (collideId <> $FF and floaterId = $FF) then collide := true;
		while (collide = false and countLaser < laserList[laserEmitId].currentLaser) do begin
			collideId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_COLLIDE_ABLE_0, 0);
			floaterId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_FLOATER_1, 1);
			if (collideId <> $FF and floaterId = $FF) then begin
				collide := true;
			end
			else begin
				
				if ((mapback2[laserx + ystart[lasery]] = $FF and bomb = false) or (mapfront[laserx + ystart[lasery]] = $FF and bomb = true)) then begin
					laserId := GetId();
					if(laserId <> $FF) then begin				
						if (xdir = -1 and ydir = 0) then begin 
							objectList[laserId].rendTilePos := tileLeft;
							objectList[laserId].physGravity := @LEFT;
						end
						else if (xdir = 1 and ydir = 0) then begin
							objectList[laserId].rendTilePos := tileRight;
							objectList[laserId].physGravity := @RIGHT;
						end
						else if (xdir = 0 and ydir = -1) then begin
						    objectList[laserId].rendTilePos := tileUp;
							objectList[laserId].physGravity := @UP;
						end
						else if (xdir = 0 and ydir = 1) then begin
							objectList[laserId].rendTilePos := tileDown;
							objectList[laserId].physGravity := @DOWN;
						end;
						objectList[laserId].rendType := rendType;
						objectList[laserId].component0 := comp0;
						objectList[laserId].component1 := $00;
						objectList[laserId].component2 := comp2;
						objectList[laserId].component3 := $00;
						objectList[laserId].transX := laserx;
						objectList[laserId].transY := lasery;
						objectList[laserId].transZ := z;
						objectList[laserId].laserTag := id;
						AddMapItem(laserId, laserx, lasery, z);
						PaintPos(laserx + ystart[lasery], false);
					end;
				end;
				lastx := laserx;
				lasty := lasery;
				laserx := CalcPositionX(laserx, xdir);
				lasery := CalcPositionY(lasery, ydir);
				inc(countLaser);
			end;
		end;
	end;
end;

procedure Animate();
var 
	i: byte;
	id: byte;
begin
	if(countAnim <> 0) then begin
		for i:=0 to countAnim do	begin
			id := animObjectList[i];
			UpdateMapItem(id, objectList[id].transX, objectList[id].transY); 
		end;
	end;
end;


@include "Sounds.ras"
procedure DecreaseTextTimer();
begin
	if(textTimer > 0) then begin
		dec(textTimer);
		if(textTimer = 0) then ClearText();
	end; 
end;

function Pos2ObjectId(pos: byte) : byte;
var
	c: byte;
begin
	c := $FF;
	if(pos <> $FF) then begin
		if(mapback2[pos] <> $FF) then c := mapback2[pos]
		else if(mapback1[pos] <> $FF ) then c := mapback1[pos]
		else if(mapmain[pos] <> $FF) then c := mapmain[pos]
		else if(mapfront[pos] <> $FF) then c := mapfront[pos];
	end;
	Pos2ObjectId := c;
end; 


procedure InitActors();
var
	i,j,x,y,c : byte;
begin
	j := 0;
	for i := 0 to @MAX_ACTORS * @ACTOR_LENGTH step @ACTOR_LENGTH do
	begin
		actorList[j].event := levActor[i];
		actorList[j].action := levActor[i+1];
		actorList[j].senderId := Pos2ObjectId(levActor[i+2]);   
		actorList[j].receiverId := Pos2ObjectId(levActor[i+3]);
		actorList[j].param0 := levActor[i+4];
		actorList[j].param1 := levActor[i+5];
		actorList[j].param2 := levActor[i+6];
		actorList[j].param3 := levActor[i+7];
		inc(j);
	end;
end;

procedure ColorLine(y: byte, col: byte);
var
	i: byte;
begin
	moveto(0,y,hi(SCREEN_COL_LOC));
	for i:=0 to 40 do screenmemory[i]:= col;
end;


procedure MenuMove(len: byte, oldMenuItem: byte);
begin
	if(mod(time,4) = 0) then begin
		if(joy1 & JOY_UP = JOY_UP or joy2 & JOY_UP = JOY_UP) then begin
			if(menuItem > 0) then dec(menuItem);
		end
		else if(joy1 & JOY_DOWN = JOY_DOWN or joy2 & JOY_DOWN = JOY_DOWN) then begin
			if(menuItem < len-1 ) then inc(menuItem); 
		end;
	end;
	ColorLine(12 + oldMenuItem, @DARK_GREY);
	ColorLine(12 + menuItem, @WHITE);
end;

@endblock

@startblock $7a00 "Code1"

@include "Actions.ras"
@include "GObjects.ras"
@include "ControlComponent.ras"
@include "PhysComponent.ras"
@include "FloaterComponent.ras"
@include "FontaineComponent.ras"
@include "LaserComponent.ras"

procedure UpdateObject(id: byte);
var
	controlId: byte;
begin
	if(objectList[id].component1 & @COMP_LASER_1 = @COMP_LASER_1) then begin 
		UpdateLaser(id);
	end;
	if(objectList[id].component2 & @COMP_FONTAINE_2 = @COMP_FONTAINE_2) then begin 
		UpdateFontaine(id);
	end;
		
	if(cycle = 0) then begin
		if(objectList[id].component0 & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then begin
			UpdatePhysics(id);
			ProcessBackObj(id);
		end;
		if(objectList[id].component1 & @COMP_FLOATER_1 = @COMP_FLOATER_1) then begin 
			UpdateFloater(id);
			ProcessBackObj(id);
		end;
		
		if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin
			controlId := objectList[id].controlId;
			if(objectList[id].moves > 0 and controlList[controlId].b_fallDown = false) then needExtraCycle := true
			else begin
				if(retryPressed = true and controlList[controlId].controlState <> @CTRL_STATE_DESTROY) then begin
					PlaySfx(@SOUND_DAMAGE); 
					objectList[id].b_physFallDown := false;
					controlList[controlId].controlState := @CTRL_STATE_DESTROY;
					controlList[controlId].controlJumpStep := 0;
		//			retryPressed := $FF;
		 		end;
				//ProcessDestroyObj(id);
				InputControl(id); 
				UpdateControl(id);
				ProcessBackObj(id);
		 	end;
		end;
	end
	else begin	
		if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin
			controlId := objectList[id].controlId;
			if(retryPressed = true and controlList[controlId].controlState <> @CTRL_STATE_DESTROY) then begin
				PlaySfx(@SOUND_DAMAGE); 
				objectList[id].b_physFallDown := false;
				controlList[controlId].controlState := @CTRL_STATE_DESTROY;
				controlList[controlId].controlJumpStep := 0;
	//			retryPressed := $FF;
	 		end;
			//ProcessDestroyObj(id);
			InputControl(id); 
			UpdateControl(id);
			ProcessBackObj(id);
		end;
	end;
		objectList[id].moves := 0;
end;

procedure Update();
var 
	i: byte;
	id: byte;
begin
	ClearAllLaser();
	i := getkey();
	if(gameMode = @MODE_SINGLE_2CHAR) then begin
		//Key::Read();
		if (i = KEY_SPACE) then begin
			PlaySfx(@SOUND_PLAYER_CHANGE);
			SwapActiveChar();
		end;
	end;
	if (i = KEY_F7) then begin
		retryPressed := true;
	end;
	if(cycle = 0 and needExtraCycle = true) then cycle := 1 else cycle := 0;

	for i:=0 to countDyn do	begin
		id := dynObjectList[i];
		UpdateObject(id);
	end;
	
	if(cycle = 1) then needExtraCycle := false;
	
end;

interrupt RasterBottomText();

interrupt RasterTopLevel();
begin
	startirq(@USE_KERNAL);
	//call(^$E003);
	asm("
	jsr $e2a9");
	setmulticolormode();
	setcharsetlocation(@tilesetLoc1);
	poke(^56320, 0, 127);
	poke(^56322, 0, 224);
	ReadJoy1();
	ReadJoy2();
	poke(^56322, 0, 255);
	SCREEN_FG_COL:=BLACK;
	if(frameStatus = 1) then begin
		if(time = 0) then begin
			SwitchBank();
			if(state = @STATE_OPEN_SCENE_REQUEST) then state := @STATE_OPEN_SCENE;

		end
		else if(time = 1 and currentBank = 0) then begin 
			copyFullScreen(^$0400, ^$4400);
		end
		else if(time = 1 and currentBank = 1) then copyFullScreen(^$4400, ^$0400)
	end;
	if(time = 2) then begin
      	frameStatus := 0;
    end;
    if(time < 4) then inc(time)
	else if(frameStatus = 1) then begin 
		time:=0;
	end;
	RasterIRQ(RasterBottomText(), 242, @USE_KERNAL);
	closeIrq();
end;

interrupt RasterBottomText();
begin
	startirq(@USE_KERNAL);
	setregularcolormode();
	setcharsetlocation(@charsetLoc1);
	SCREEN_FG_COL:=statusCol;

	@IFDEF DEBUG
	if(time = 2) then begin
		moveto(0,24,screen);
		fillfast(screenmemory,$20,40);
	end;
	@ENDIF
		
	RasterIRQ(RasterTopLevel(),10,@USE_KERNAL);
	closeIrq();
end;


interrupt RasterMain();

interrupt RasterMainTop();
var
	i:byte;
begin
	startirq(@USE_KERNAL);
	setmulticolormode();
	setcharsetlocation(@tilesetLoc1);
	
	//setcharsetlocation(@logoLoc);

	multicolor_char_col[1]:=green;
	multicolor_char_col[2]:=white;

	RasterIRQ(RasterMain(), 110, @USE_KERNAL);

	closeIrq();

end;


interrupt RasterMain();
var
	levStr: string = "00";
	levStr2: string = "00";
	pos : byte;
	len: byte;
begin
	startirq(@USE_KERNAL);
	setregularcolormode();
	setcharsetlocation(@charsetLoc1);
	
	ReadJoy1();
	ReadJoy2();
	inc(time);
	levStr := "00";
	levStr2 := "00";
	
	if(state = @STATE_MENU or state = @STATE_MENU_INPUT) then begin
		if(levelSingle >= 9) then pos := 0 else pos := 1; 
		str::itoa(levelSingle + 1, #levStr + pos, 10);
		if(levelCoop >= 9) then pos := 0 else pos := 1; 
		str::itoa(levelCoop + 1, #levStr2 + pos, 10);
		@ifdef IS_DEMO 
		Call(^$2003);
		@endif
		@ifdef CRT_VERSION 
		Call(^$2003);
		@endif
		
		if(mod(time,8) = 0 and (joy1 & JOY_FIRE = JOY_FIRE or joy2 & JOY_FIRE = JOY_FIRE)) then begin
			if(menuItem = 0 or menuItem = 3) then InitGame(levelSingle, levelCoop, @MODE_SINGLE);
			if(menuItem = 1) then InitGame(levelSingle, levelCoop, @MODE_SINGLE_2CHAR);
			if(menuItem = 2 or menuItem = 4) then InitGame(levelSingle, levelCoop, @MODE_COOP);
			state := @STATE_OPEN_SCENE; //TODO
		end;
		if(mod(time,4) = 0 and (joy1 & JOY_LEFT = JOY_LEFT or joy2 & JOY_LEFT = JOY_LEFT)) then begin
			if(menuItem = 3) then DecLevel(@MODE_SINGLE);
			if(menuItem = 4) then DecLevel(@MODE_COOP);
		end;
		if(mod(time,4) = 0 and (joy1 & JOY_RIGHT = JOY_RIGHT or joy2 & JOY_RIGHT = JOY_RIGHT)) then begin
			if(menuItem = 3) then IncLevel(@MODE_SINGLE);
			if(menuItem = 4) then IncLevel(@MODE_COOP);
		end;
		
		Screen::PrintStringColor(#levStr,33,15,@WHITE);
		Screen::PrintStringColor(#levStr2,31,16,@WHITE);
		
		MenuMove(5, menuItem);
		RasterIRQ(RasterMainTop(),28,@USE_KERNAL);
	end
	
	else if(state = @STATE_OPEN_SCENE or state = @STATE_OPEN_SCENE_INPUT) then begin

		asm("
		jsr $e2a9");
		if(mod(time,8) = 0 and (joy1 & JOY_FIRE = JOY_FIRE or joy2 & JOY_FIRE = JOY_FIRE)) then begin
			if(menuItem = 0) then state := @STATE_INIT
			else if(menuItem = 1) then state := @STATE_MENU;
		end;
		MenuMove(2, menuItem);
	end;
		
	closeIrq();
end;



procedure InitAnimations();
var
	pa: pointer of animObject;

begin
	// walk left
	// l            r            u            d
	// 00 01 02 03  04 05 06 07  08 09 0a 0b  0c 0d 0e 0f 

	// walk right
	// l            r            u            d
	// 10 11 12 13  14 15 16 17  18 19 1a 1b  1c 1d 1e 1f 

	// stand
	// l  r  u  d
	// 20 21 22 23
	
	// swim l
	// l     r     u     d
	// 24 25 26 27 24 25 26 27

	// swim r
	// l     r     u     d
	// 28 29 2a 2b 28 29 2a 2b

	// TODO	
	// climb
	// l     r     u     d
	// 2c 2d 2e 2f 30 31 32 33

	// TODO	
	// robe
	// l     r     u     d
	// 34 35 36 37 48 49 4a 4b

 
	
	pa := #animList[@ANIM_WALK_L];
	pa.animSeq[0] := $00;
	pa.animSeq[1] := $04;
	pa.animSeq[2] := $08;
	pa.animSeq[3] := $0c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_WALK_R];
	pa.animSeq[0] := $10;
 	pa.animSeq[1] := $14;
	pa.animSeq[2] := $18;
	pa.animSeq[3] := $1c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_STAND];
	pa.animSeq[0] := $20; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_L];
	pa.animSeq[0] := $24; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_R];
	pa.animSeq[0] := $28; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_CLIMB];
	pa.animSeq[0] := $2c; 
 	pa.animSeq[1] := $30;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_ROBE];
	pa.animSeq[0] := $34; 
 	pa.animSeq[1] := $38;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_PORTAL];
	pa.animSeq[0] := $A6; 
 	pa.animSeq[1] := $A8;
	pa.animSeq[2] := $AA;
	pa.animSeq[3] := $AC;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_SWITCH_ON];
	pa.animSeq[0] := $6E; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_SWITCH_OFF];
	pa.animSeq[0] := $70; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_DOOR_ON];
	pa.animSeq[0] := $76; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_DOOR_OFF];
	pa.animSeq[0] := $74; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_EXIT_ON];
	pa.animSeq[0] := $22; 
 	pa.animSeq[1] := $20;
	pa.animSeq[2] := $1e;
	pa.animSeq[3] := $1e;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	
	
	pa := #animList[@ANIM_EXIT_OFF];
	pa.animSeq[0] := $1e; 
 	pa.animSeq[1] := $20;
	pa.animSeq[2] := $22;
	pa.animSeq[3] := $22;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	

end;

procedure InitMap();
var 
	i,x,y,c : byte;
begin
	ClearMap();
	countDyn := 0;
	countAnim := 0;

	for i:= 0 to @MAX_OBJECTS do begin
		deletedObjects[@MAX_OBJECTS - 1 - i] := i;
	end;	
	for i := 0 to @DIMTILES do
	begin
		c := lev[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_FONTAINE_DOWN: InitFontaine(x,y, 176, @DOWN);
			@LEV_FONTAINE_UP: InitFontaine(x,y,178,@UP);
			@LEV_FONTAINE_LEFT: InitFontaine(x,y, 180, @LEFT);
			@LEV_FONTAINE_RIGHT: InitFontaine(x,y,182,@RIGHT);
			@LEV_CANNON_DOWN: InitCannon(x,y, 14, @DOWN);
			@LEV_CANNON_UP: InitCannon(x,y,12,@UP);
			@LEV_CANNON_LEFT: InitCannon(x,y, 16, @LEFT);
			@LEV_CANNON_RIGHT: InitCannon(x,y,18,@RIGHT);
		end;
	end;	
	
	for i := 0 to @DIMTILES do
	begin
		c := lev[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_CHARACTER: InitCharacter(x,y,0);
			@LEV_CHARACTER2: begin
				if(gameMode = @MODE_SINGLE_2CHAR or gameMode = @MODE_COOP) then InitCharacter(x,y,1);
			end;
			@LEV_BRICK: InitBrick(x, y);
			@LEV_STONE: InitStone(2, x, y, true);
			@LEV_BLOCK: InitStone(114, x, y, false);
			@LEV_WATER: InitWater(x, y);
			@LEV_WATER_UP: InitWaterFlow(x, y, 23, @UP);
			@LEV_WATER_DOWN: InitWaterFlow(x, y, 22, @DOWN);
			@LEV_WATER_LEFT: InitWaterFlow(x, y, 62, @LEFT);
			@LEV_WATER_RIGHT: InitWaterFlow(x, y, 63, @RIGHT);
			@LEV_SAND: InitSand(x, y);
			@LEV_SHIFT_UP: InitShiftPlattform(x, y,4,@UP);
			@LEV_SHIFT_DOWN: InitShiftPlattform(x, y,6,@DOWN);
			@LEV_SHIFT_RIGHT: InitShiftPlattform(x, y, 10,@RIGHT);
			@LEV_SHIFT_LEFT: InitShiftPlattform(x, y, 8,@LEFT);
			@LEV_LADDER: InitLadder(x,y);
			@LEV_ROBE_UP: InitRobe(x,y,100,@DOWN);
			@LEV_ROBE_DOWN: InitRobe(x,y,102,@UP);
			@LEV_ROBE_LEFT: InitRobe(x,y,106,@LEFT);
			@LEV_ROBE_RIGHT: InitRobe(x,y,104,@RIGHT);
			@LEV_PORTAL: InitPortal(x,y,@UP);
			@LEV_PORTAL_ACTIVATE: InitPortalActivate(x,y);
			@LEV_GRAVPAD_UP: InitGravPad(x,y,38,@UP);
			@LEV_GRAVPAD_DOWN: InitGravPad(x,y,80,@DOWN);
			@LEV_GRAVPAD_LEFT: InitGravPad(x,y,82,@LEFT);
			@LEV_GRAVPAD_RIGHT: InitGravPad(x,y,84,@RIGHT);
			@LEV_MIRROR_LEFT: InitMirror(x,y, 96, @TURN_LEFT);
			@LEV_MIRROR_RIGHT: InitMirror(x,y, 98, @TURN_RIGHT);
			@LEV_GLASS: InitMirror(x,y,36, @TURN_THROUGH);
			@LEV_LASER_TRANSPORT: InitLaserTransport(x,y);
//			@LEV_LASER_TRANSPORT_ONCE: InitLaserTransportOnce(x,y);
			@LEV_PUSH_BOX: InitBox(x,y, 162 , 1);
			@LEV_PULL_BOX: InitBox(x,y, 164 , -1);
			@LEV_SWITCH_MANUAL: InitSwitchManual(x,y);
			@LEV_DOOR: InitDoor(x,y);
			@LEV_EXIT: InitExit(x,y);
			@LEV_WAYPOINT: InitWaypoint(x,y);
		end;
	end;
end;

procedure OpenMain();
var
	i: byte;
	levStr: string = "00";
	pos : byte;
	len: byte;
	
begin
	preventirq();
	ScreenOff();
	SetBank(VIC_BANK0);
	setcharsetlocation(@charsetLoc1);
	screen := hi(screen_char_loc);
	clearscreen($20,^$0400);
	clearscreen($20,^$4400);
	clearscreen(BLACK,^$D800);
	SCREEN_FG_COL:=BLACK;
	InitSprites();
	
	time := 0;
	menuItem := 0;
	levStr[0] := '0';
	if(state = @STATE_OPEN_SCENE) then begin 
		InitLevel();
		if(gameMode = @MODE_SINGLE) then begin
			if(levelSingle >= 9) then pos := 0 else pos := 1; 
			str::itoa(levelSingle + 1, #levStr + pos, 10)
		end
		else begin
			if(levelCoop >= 9) then pos := 0 else pos := 1; 
			str::itoa(levelCoop + 1, #levStr + pos, 10)
		end;
		
		Screen::PrintStringColor("LEVEL: ",16,8,5);
		Screen::PrintStringColor(#levStr,23,8,5);
		
		len := str::strlen(levStrings[0]);
		pos := 20 - (len / 2);
	
		Screen::PrintStringColor(levStrings[0],pos,10,5);

		Screen::PrintStringColor("START LEVEL",15,12,@DARK_GREY);
		Screen::PrintStringColor("MAIN MENU",16,13,@DARK_GREY);
	
		Screen::PrintStringColor("PRESS 'DEL' TO RETRY",10,22,@DARK_GREY);
		PlaySfx(@SOUND_END);	
		if(gameMode = @MODE_SINGLE_2CHAR) then Screen::PrintStringColor("PRESS 'SPACE' TO SWAP CHARACTER",4,23,@DARK_GREY);
		if(gameMode <> @MODE_SINGLE) then begin
			if(levBothMustComplete = true) then Screen::PrintStringColor("BOTH PLAYERS MUST EXIT",9,24,@DARK_GREY) 
			else Screen::PrintStringColor("ONLY ONE PLAYER MUST EXIT",9,24,@DARK_GREY);
		end;
		state := @STATE_OPEN_SCENE_INPUT;
		ScreenOn();
		StartRasterChain(RasterMain(), 0,@USE_KERNAL); // Don't use kernal
	end
	else begin
		@ifdef CRT_VERSION
		LoadMusicFromCrt();
		InitSid(^$2000);
		@endif  
		@ifdef IS_DEMO
		asm( 
	"
		ldx #<musicStr
		ldy #>musicStr
		jsr $200
	");
		InitSid(^$2000);
		@endif


		BlockMemCpy(^@logoLoc , ^@tilesetLoc1, 4);
		for i:=0 to 24 do begin
			moveto(i+8,1,screen);
			
			screenmemory[0]:=i;
			screenmemory[40]:=i+24;
			screenmemory[80]:=i+48;
			screenmemory[120]:=i+72;
			screenmemory[160]:=i+96;
			moveto(i+8,1,hi(SCREEN_COL_LOC));
			screenmemory[0]:= $AE;
			screenmemory[40]:= $AE;
			screenmemory[80]:= $AE;
			screenmemory[120]:= $AE;
			screenmemory[160]:= $AE;
		end;	
		Screen::PrintStringColor(#txtSelectGameMode,12,9,5);

		Screen::PrintStringColor(#txtSinglePlayer,14,12,@DARK_GREY);
		Screen::PrintStringColor(#txtSinglePlayer2Chars,6,13,@DARK_GREY);
		Screen::PrintStringColor(#txtCoop,12,14,@DARK_GREY);

		Screen::PrintStringColor(#txtSingleStart,6,15,@DARK_GREY);
		Screen::PrintStringColor(#txtCoopStart,11,16,@DARK_GREY);
		
		Screen::PrintStringColor(#txtAuthor,11,23,@WHITE);
		Screen::PrintStringColor(#txtMusican,13,24,@WHITE);
		
	
		state := @STATE_MENU_INPUT;
		ScreenOn();
		StartRasterChain(RasterMainTop(), 0,@USE_KERNAL); // Don't use kernal
	end;
	enableirq();
	enablerasterirq();
end;


procedure InitScene();
begin
	preventirq();
	ScreenOff();
	multicolor_char_col[1]:=brown;
	multicolor_char_col[2]:=grey;
	clearscreen($FF,^$0400);
	clearscreen($FF,^$4400);
	clearscreen(BLACK,^$D800);
	BlockMemCpy(^@tilesetLoc2 , ^@tilesetLoc1, 8);
	BlockMemCpy(^@spriteLoc2 , ^@spriteLoc1, 16);

	InitMap();
	InitActors();	
	SwitchBank();
	PaintFull();
	SwitchBank();
	PaintFull();
	InitSprites();
	InitAnimations();
	ClearText();
	state := @STATE_PLAY;
	ScreenOn();
	PlaySfx(@SOUND_SCENE_START);	
	StartRasterChain(RasterTopLevel(), 0,@USE_KERNAL); // Don't use kernal
	enableirq();
	enablerasterirq();	
	DispatchEvent(@EVENT_INIT_LEVEL, $FF, $FF, $FF);
end;

procedure GameLoop();
begin
	While(true) do begin
		case state of
			@STATE_MENU: OpenMain();
			@STATE_OPEN_SCENE: OpenMain();
			@STATE_INIT: InitScene();
			@STATE_PLAY: begin
				frameStatus := 1; // will be updated in raster chain
				time := 0;
				while(state = @STATE_PLAY) do begin
					if(frameStatus = 0)	then begin
						Update();
						Animate();
						CycleWater();
						DecreaseTextTimer();
						frameStatus := 1;
						inc(globaltime);	
					end;					
				end;
			end;
		end;
	end;	
end;

@endblock

begin
@ifndef IS_DEMO 

// Executed in stand-alone
	disableciainterrupts();
	preventirq();
	setmemoryconfig(1,@USE_KERNAL,0);
@endif
		
	SCREEN_BG_COL:=BLACK;
	SCREEN_FG_COL:=BLACK;
	clearscreen($FF,^$0400);
	clearscreen($FF,^$4400);
	clearscreen(BLACK,^$D800);
	setmemoryconfig(1,0,0);
@ifdef IS_DEMO
	maxSingleLevels := Peek(^$08fd, 0);
	maxMultiLevels := Peek(^$08fe, 0);
@endif
@ifndef IS_DEMO
	maxSingleLevels := 40;
	maxMultiLevels := 30;
@endif
	InitGame(0, 0, @MODE_COOP);
	state := @STATE_MENU;
	poke(^$d418,0,15);
	
	GameLoop();
	Loop();
end.