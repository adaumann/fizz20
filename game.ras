program game;

@ignoremethod "initmoveto"

@use "system/str"
@use "input/key"

@export "chr/tileset.flf" "chr/tileset.bin" 128	

@macro "PLAY_SOUND" 3
     writeln('psnd['+p0+'] := #'+p1+'; vsnd['+p0+'] := '+p2+'; vsndTime['+p0+'] := 0;');
@endmacro


@startblock $0400 "Variables"
var	
	//@define DEBUG 1
	//@define OVERFLOW_CHECK 1
	@define USE_KERNAL 0

	// Charsets

	@define tilesetLoc1 $1800
	@define tilesetHeroLoc1 $1C00 
	@define tilesetCol $0f00
	
	@define SCREEN_ADDR1 	$1000		// Screen address1
	@define SCREEN_ADDR2 	$1e00		// Screen address2	
	@define COLOR_ADDR1	$9400		// Colour address
	@define COLOR_ADDR2	$9600		// Colour address
	@define SCREEN_WIDTH 20			// Custom VIC 20 screen width
	@define SCREEN_HEIGHT 20		// Custom VIC 20 screen height	
	// Automatically export charsets 
	tileset :  incbin("chr/tileset.bin", @tilesetLoc1, 0, $80 * 8);
	tilesetColors :  incbin("chr/tileset_color.bin", @tilesetCol, 0, $80);
	tilesetHero :  incbin("chr/hero.bin", @tilesetHeroLoc1,0 , $40 * 8);
	
	scr1 : array[ @SCREEN_HEIGHT ] of integer; // an array to store the address of each row of screen memory
	scr2 : array[ @SCREEN_HEIGHT ] of integer; // an array to store the address of each row of screen memory
	col1 : array[ @SCREEN_HEIGHT ] of integer; // an array to store the address of each row of screen memory
	col2 : array[ @SCREEN_HEIGHT ] of integer; // an array to store the address of each row of screen memory
//	rands: array[256] of byte;

	fileName: pointer;

	// Double Buffer
	currentBank: byte=0;
	time: byte=0;
	globaltime: byte=0;
	frameStatus: byte;
	screen: byte;
	countSprite: byte=0;
	cycle: byte;
	needExtraCycle : boolean;
	pos: byte;
	statusCol: byte;
	maxSingleLevels: byte;
	maxMultiLevels: byte;
	waterstep: byte;
	raster: byte;
	
	// Game	
	@define SCENES_SIZE 1
	@define DIMX 20
	@define DIMY 12
	@define DIMZ 4
	@define MAX_OBJECTS 200
	@define MAX_CONTROLS 2
	@define MAX_LASERS 12
	@define MAX_LASER_SIZE 30
	@define MAX_ACTORS 32
	@define MAX_LEV_STRINGS 8
	@define ACTOR_LENGTH 8

	@define DIMTILES 240
	@define DIMANIMS 14
	@define Z_BACK2 3
	@define Z_BACK1 2
	@define Z_MAIN 1
	@define Z_FRONT 0
	@define UNKNOWN $FF
	@define DOWN 7
	@define UP 1
	@define LEFT 3
	@define RIGHT 5
	@define SHIFT_DOWN 4
	@define SHIFT_UP 5
	@define SHIFT_LEFT 6
	@define SHIFT_RIGHT 7
	@define DOWN_LEFT 6
	@define DOWN_RIGHT 8
	@define UP_LEFT 0
	@define UP_RIGHT 2
	@define STOP 12
	@define AREA_OUT $FF
	@define AREA_DOWN 0
	@define AREA_UP 1
	@define AREA_LEFT 2
	@define AREA_RIGHT 3
	@define AREA_CENTER 4
	@define LASER_STEP 4
	@define TURN_RIGHT 1
	@define TURN_LEFT 2
	@define TURN_THROUGH  3
	@define ON 1
	@define OFF $FF
	@define LASER_TYPE_USER 10 
	@define REND_TYPE_TILE 0
	@define REND_TYPE_SPRITE 1
	@define REND_TYPE_BYTE 2
	
	@define ANIM_MODE_FIX 0
	@define ANIM_MODE_LR 1
	@define ANIM_MODE_LR_REPEAT 2
	@define ANIM_MODE_MANUAL 3
	
	@define ANIM_WALK_L 0
	@define ANIM_WALK_R 1
	@define ANIM_STAND 2
	@define ANIM_SWIM_L 3
	@define ANIM_SWIM_R 4
	@define ANIM_CLIMB 5
	@define ANIM_ROBE 6
	@define ANIM_PORTAL 7
	@define ANIM_SWITCH_ON 8
	@define ANIM_SWITCH_OFF 9
	@define ANIM_DOOR_ON 10
	@define ANIM_DOOR_OFF 11
	@define ANIM_EXIT_ON 12
	@define ANIM_EXIT_OFF 13
	
	@define SOUND_TRANSPORT 18	// ->19
	@define SOUND_DAMAGE 7
	@define SOUND_LASER 11
	@define SOUND_JUMP 3
	@define SOUND_STEP 8
	@define SOUND_SWIM 9 // ->1
	@define SOUND_GRAV_ACTIVATE 10 // ->15
	@define SOUND_SWITCH_ON 4 // ->16
	@define SOUND_SWITCH_OFF 5
	@define SOUND_FALL_CRASH 17
	@define SOUND_FALL 2
	@define SOUND_SHIFT 13
	@define SOUND_LADDER 0
	@define SOUND_SCENE_START 6
	@define SOUND_END 16
	@define SOUND_PLAYER_CHANGE 12
	@define SOUND_PORTAL_ACTIVATE 20 
	@define SOUND_PORTAL 21 
	@define SOUND_EXIT 22
	@define SOUND_EXIT_CLOSE 23 

	psnd : array[4] of integer = (0,0,0,0);
	vsnd : array[4] of byte = (0,0,0,0);
	vsndTime : array[4] of byte = (0,0,0,0);
	soundPointer : pointer; 
	
	ticks,i: byte;
	sndFlag : byte = true;
	// need local variables set OFF in the TRSE project settings
	@define VICvolume	$900e
	@define VICsnd1		$900a
	@define VICsnd2		$900b
	@define VICsnd3		$900c
	@define VICsnd4	    $900d

	// bitwise settings
	@define VSA_IDLE	0	// 
							// values 1-31 (low nibble) = duration
	@define VSA_INC		$80	// play incremental note, low nibble contains increment value
	@define VSA_DEC		$40	// play decremental note, low nibble contains decrement value
	@define VSA_NOTE	$20	// play note
	@define VSA_PAUSE	$10	// no sound
							// note value 128 - 255	

	// sound definitions
	// format:  action, duration
	noSound : byte = @VSA_IDLE;  // used to point all sounds to stop / idle

	sndFall : array[] of byte = (
		$81,7, $20,2, $43,4,
		@VSA_IDLE);
	
	sndStep : array[] of byte = (
		$20,8,
		@VSA_IDLE);
		
	sndSceneStart : array[] of byte = (
		$41,35,	$42,8, $41,6, $20,12, $83,25,
		@VSA_IDLE);
		
	sndTransport : array[] of byte = (
		$8f,4, $42,12, $41,2,
		@VSA_IDLE);
		
	sndPortal : array[] of byte = (
		$41,10, $10,3, $41,8, $10,3, $41,6,
		@VSA_IDLE);

	sndPortalActivate : array[] of byte = (
		$42,4, $10,3, $8f,4,
		@VSA_IDLE);
		
	sndShift : array[] of byte = (
		$20,1, $10,1, $20,1,
		@VSA_IDLE);

	sndLaser : array[] of byte = (
		$20,1, $10,1, $41,10,
		@VSA_IDLE);
			
	sndLadder : array[] of byte = ( $44,11, $85,3, $20,7, @VSA_IDLE);

	sndJump : array[] of byte = ( $81,3, @VSA_IDLE);

	sndExit : array[] of byte = ( $10,20, $42,5, $10,10, $20,15, $83,30, @VSA_IDLE);

	sndSwim : array[] of byte = ( $8f,5, $20,15, $42,3, @VSA_IDLE);

	sndGravActivate : array[] of byte = ( $41,12, $42,4, $81,7, $10,2, $8f,5, @VSA_IDLE);

	sndPlayerChange : array[] of byte = ( $81,4, $20,3, $42,8, @VSA_IDLE);

	sndSwitchOn : array[] of byte = ( $20,2, $10,2, $20,2, @VSA_IDLE);

	sndSwitchOff : array[] of byte = ( $20,3, $10,2, $41,12, @VSA_IDLE);

	sndExitClose : array[] of byte = ( $20,15, $10,7, $89,2, $20,12, $10,6, $89,2, $20,11, @VSA_IDLE);

	sndExplosion : array[] of byte = ( $44,3, $20,6, $81,5, @VSA_IDLE);

	sndEnd : array[] of byte = ( $41,35, $42,10, $41,6, $20,12, $83,25, @VSA_IDLE);	

	collAreaUp: array[9] of byte = (8,7,6,5,4,3,2,1,0);
	collAreaLeft: array[9] of byte = (2,5,8,1,4,7,0,3,6);
	collAreaRight: array[9] of byte = (6,3,0,7,4,1,8,5,2);

	shiftAreaDownX: array[9] of byte = (-1, 0, 1 , -1, 0, 1, -1, 0, 1);
	shiftAreaUpX: array[9] of byte = (1, 0, -1, 1, 0, -1, 1, 0, -1);
	shiftAreaLeftX: array[9] of byte = (1, 1, 1, 0, 0, 0, -1, -1, -1);
	shiftAreaRightX: array[9] of byte = (-1, -1, -1,0, 0, 0, 1, 1, 1);

	shiftAreaDownY: array[9] of byte = (-1, -1, -1, 0, 0, 0, 1, 1, 1);
	shiftAreaUpY: array[9] of byte = ( 1, 1, 1 , 0, 0, 0, -1, -1, -1);
	shiftAreaLeftY: array[9] of byte = ( -1, 0, 1, -1, 0, 1, -1, 0, 1);
	shiftAreaRightY: array[9] of byte = ( 1, 0, -1,  1, 0, -1, 1, 0, -1);

	ystart: array[12] of byte = ( 0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220 );
	
	tempPointer: pointer of byte;
	
	@define STATE_MENU 0
	@define STATE_INIT 1
 	@define STATE_OPEN_SCENE 2
	@define STATE_PLAY 3
	@define STATE_CLOSE_SCENE 5
	@define STATE_MENU_INPUT 6
	@define STATE_OPEN_SCENE_INPUT 7
	@define STATE_OPEN_SCENE_REQUEST 8
	
	@define MODE_SINGLE 0
	@define MODE_SINGLE_2CHAR 1
	@define MODE_COOP 2
		
	@define COMP_PHYSICS_0          %00000001
	@define COMP_COLLIDE_ABLE_0     %00000010
	@define COMP_SHIFT_PLATTFORM_0  %00000100	
	@define COMP_DESTROY_COLLIDE_0  %00001000
 	@define COMP_ERASE_ABLE_0       %00010000
 	@define COMP_WATER_0            %00100000
	@define COMP_ANIMATION_0	    %01000000	
	@define COMP_CONTROL_0		    %10000000
    @define COMP_PUSHPULL_1 	    %00000001
    @define COMP_CLIMB_ABLE_1 	    %00000010
    @define COMP_ROBE_ABLE_1 	    %00000100
    @define COMP_FLOATER_1 		    %00001000
	@define COMP_PORTAL_1 		    %00010000
	@define COMP_GRAVPAD_1		    %00100000
	@define COMP_LASER_1		   	%01000000
	@define COMP_MIRROR_1		    %10000000
	@define COMP_DESTROY_ABLE_2     %00000001
	@define COMP_LASERBEAN_2		%00000010
	@define COMP_LASERTRANS_ABLE_2  %00000100
	@define COMP_LASERONCE_2        %00001000
	@define COMP_PORTAL_ACTIVATE_2  %00010000
	@define COMP_FONTAINE_2         %00100000
	@define COMP_SWITCH_2           %01000000
	@define COMP_DOOR_2             %10000000
	@define COMP_EXIT_3             %00000001
	@define COMP_WAYPOINT_3         %00000010
	@define COMP_BULK_PHYS_3		   %00000100
 	// https://www.aivosto.com/articles/petscii.pdf
 	@define LEV_CHARACTER $40  //@
 	@define LEV_CHARACTER2 $25 //%
	@define LEV_BRICK $61 // a
	@define LEV_STONE $62 // b
	@define LEV_SAND $73 // s
	@define LEV_WATER $3d // =
	@define LEV_WATER_UP $27 // '
	@define LEV_WATER_DOWN $26 // &
	@define LEV_WATER_LEFT $7b // ?  
	@define LEV_WATER_RIGHT $7d // ?
	@define LEV_SHIFT_DOWN $59 // Y
	@define LEV_SHIFT_UP $5E // ^
	@define LEV_SHIFT_LEFT $3C // <
	@define LEV_SHIFT_RIGHT $3E // >
	@define LEV_LADDER $68 // h
	@define LEV_ROBE_DOWN $5f  // _ 
	@define LEV_ROBE_UP $2d // -
	@define LEV_ROBE_LEFT $21 // !
	@define LEV_ROBE_RIGHT $7C // |
	@define LEV_PORTAL $6F // o
	@define LEV_GRAVPAD_DOWN $32 // 2
	@define LEV_GRAVPAD_UP $38 // 8
	@define LEV_GRAVPAD_LEFT $34 // 4
	@define LEV_GRAVPAD_RIGHT $36 // 6
	@define LEV_MIRROR_LEFT $6e // n 
	@define LEV_MIRROR_RIGHT $6d // m
	@define LEV_GLASS $67 // g
	@define LEV_LASER_TRANSPORT $74 // t
	@define LEV_PUSH_BOX $64 // d 
	@define LEV_PULL_BOX $65 // e
	@define LEV_PORTAL_ACTIVATE  $63 // c
	@define LEV_FONTAINE_DOWN $5b // [
	@define LEV_FONTAINE_LEFT $28 // (
	@define LEV_FONTAINE_RIGHT $29 // )
	@define LEV_FONTAINE_UP $5d // ]
	@define LEV_CANNON_DOWN $31 // 1
	@define LEV_CANNON_UP $39 // 9
	@define LEV_CANNON_LEFT $37 // 7
	@define LEV_CANNON_RIGHT $33 // 3
	@define LEV_SWITCH_MANUAL $72 // r
	@define LEV_DOOR $78 // x
	@define LEV_EXIT $58 // X
	@define LEV_WAYPOINT $2E // .
	@define LEV_BLOCK $66 // f

	@define CTRL_STATE_WALK 0
	@define CTRL_STATE_CLIMB 1
	@define CTRL_STATE_ROBE 2
	@define CTRL_STATE_SWIM 3
	@define CTRL_STATE_JUMP 4
	@define CTRL_STATE_DESTROY 5
	@define CTRL_STATE_RETRY 6
	@define CTRL_STATE_EXITED 7
	@define CTRL_STATE_DIE 8

	@define EVENT_INIT_LEVEL 0
	@define EVENT_SWITCH_ON 1
	@define EVENT_SWITCH_OFF 2
	@define EVENT_WAYPOINT_ENTER 3
	@define EVENT_WAYPOINT_LEAVE 4
	
	@define ACTION_DOOR_OPEN 1
	@define ACTION_DOOR_CLOSE 2
	@define ACTION_EXIT_OPEN 3
	@define ACTION_EXIT_CLOSE 4
	@define ACTION_PRINT_TEXT 5
	@define ACTION_CLEAR_TEXT 6
	@define ACTION_LASERCANNON_ON 7
	@define ACTION_LASERCANNON_OFF 8
	@define ACTION_FONTAINE_ON 9
	@define ACTION_FONTAINE_OFF 10
	@define ACTION_SET_GRAV 11
	@define ACTION_SWITCH_ON 12
	@define ACTION_SWITCH_OFF 13
	@define ACTION_SET_GRAV_BULK 14
	
	
	@define DO_ACTIVATE_SWITCH_START 7
	txtDoActiveSwitch: string=("SWITCH");
	@define ACTIVATE_SWITCH_START 2
	txtActiveSwitch:   string=("SWITCH ACTIVATED");
	@define DEACTIVATE_SWITCH_START 1
	txtDeactiveSwitch: string=("SWITCH DEACTIVATED");
	@define EXIT_CLOSED_START 4
    txtExitClosed: string=("EXIT CLOSED");
	@define CHAR_SWAP_RED 5
	txtCharSwapRed: string=("ACTIVE: WHITE");
	@define CHAR_SWAP_GREEN 4
	txtCharSwapGreen: string=("ACTIVE: GREEN");
	@define PLAYER_EXIT 3
	txtPlayerExit: string=("PLAYER EXITED");
    txtSelectGameMode: string=("SELECT GAME MODE"); //2  
    txtSinglePlayer: string=("ONE PLAYER"); // 3
    txtSinglePlayer2Chars: string=("ONE PLAYER TWO CHARS"); //0
    txtCoop: string=("TWO PLAYER CO-OP"); // 2 
    txtSingleStart: string=("1P START LEVEL: XX"); // 1
    txtCoopStart: string=("2P START LEVEL: XX"); //1
	txtLogo: string=("F @ Z Z");
    txtAuthor: string=("CODE: ANDY DAUMANN"); //1
	txtLevel: string=("LEVEL: XX"); // 5
	txtStartLevel: string=("START LEVEL"); // 5
    txtMainMenu: string=("MAIN MENU"); // 5
    txtPressDel: string=("'F7' TO RETRY"); // 3
    txtPressSpace: string=("'SPACE' TO SWAP"); // 2
    txtPressWasd: string=("P2: USE 'WASD'+'J'"); // 2
	txtBothMustComplete: string=("BOTH MUST EXIT"); // 3 
	txtOneMustComplete:	string=("ONLY ONE MUST EXIT"); // 1
    
	countObjects: byte;
	deletedObjects: Array[@MAX_OBJECTS] of byte;
	dynObjectList : Array[@MAX_OBJECTS] of byte;
	animObjectList : Array[@MAX_OBJECTS] of byte;
	countDyn: byte;
	countAnim: byte;
	countLasers: byte;
	mapback2 : Array[@DIMTILES] of byte;
	mapback1 : Array[@DIMTILES] of byte;
	mapmain : Array[@DIMTILES] of byte;
	mapfront : Array[@DIMTILES] of byte;
	portals: Array [2] of byte;
	lastPortal: byte;
	state: byte;
	sp: pointer;
	dp: pointer;
	textTimer: byte;
	levelSingle: byte;
	levelCoop: byte;
	nextLevel: byte;
	gameMode: byte;
	activeChar: byte;
	retryPressed: byte;
	menuItem: byte = 0;
	simJoy: byte;	
	
	@define ANIM_CONSIDER_GRAV_IGNORE 0
	@define ANIM_CONSIDER_GRAV_FULL 1
//	@define ANIM_CONSIDER_GRAV_HALF 2
	
	animObject = class
		animSeq: array[4] of byte;
		considerGravity: byte;
		size: byte;
		speed: byte;
		mode: byte;
	end;
	animList : Array[@DIMANIMS] of animObject;

	actorObject = record
		event: byte;
		senderId: byte;
		action: byte;
		receiverId: byte;
		param0, param1, param2, param3: byte;
	end;

	controlObject = record
		controlJumpStep: byte;
		controlState: byte;
		controlFollowKeyRight, controlFollowKeyLeft: byte;
		b_controlPressLeft, b_controlPressRight, b_controlPressUp, b_controlPressDown, b_controlPressAction: byte;
		b_firePressed: byte;
		controlLastPortal: byte;
		b_waitRelease, b_release: byte;
		waypointId: byte;
		lastWaypointId: byte;
		controlCollideLaserTag: byte;
		b_fallDown: byte;
	end;
	
	laserObject = record
		laserDir: byte;
		lastLaserDir: byte;
 		laserLastTransportAble: byte;
 		laserType : byte;
		currentLaser: byte; 		
	end;
	controlList : Array[@MAX_CONTROLS] of controlObject;
	actorList : Array[@MAX_ACTORS] of actorObject;
	laserList : Array[@MAX_LASERS] of laserObject;

@endblock

@startblock $A000 "level"

    lev: string = ("x {aaaaaa  a  a  aaa  ^a aa  a  aa    aa6 e  aaa  aa   d  aaa a6    [12    ^ ^Yaa  %  o   ^      ^Yaa&     ^         ^Yaa&    ^)         ^Yaa&        (   h     a& 4------====hh   aa&m   n   b@   = f aaX  x===ss rs8 h o aaaaaaaaaaaaaaa>>aaaa");
    //lev: string = ("                                                                                                                                                                                   @                                       aaaaaaaaaaaaaaa>>aaaa");
										  //event, action, senderpos, receiverpos, p1, p2, p3, p48
	levActor: Array[@MAX_ACTORS * @ACTOR_LENGTH] of byte = (1, 1 ,211 , 204, $FF, $FF, $FF, $FF,
												            2, 2 ,211 , 204, $FF, $FF, $FF, $FF,	 
												 		    1, 1, 211,  0,   $FF, $FF, $FF, $FF,
												 			2, 2, 211,  0, $FF, $FF, $FF, $FF,
												 			1, 3, 211, 201,$FF, $FF, $FF, $FF,
												 			2, 4, 211, 201,$FF, $FF, $FF, $FF,
												 			3, 5, 211, $FF, $00, 17, 10, $FF,
												 			4, 6, 211, $FF, $FF, $FF, $FF, $FF,
												 			0, 5, $FF, $FF, $00, 17, 10, $FF,
												 			3, 5, 70, $FF, $00, 17, 10, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF, 	
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF,
												 			$FF, $FF, $FF, $FF,$FF, $FF, $FF, $FF); 	

	levBothMustComplete: boolean = true;
	levStrings: Array[@MAX_LEV_STRINGS] of string = ("WELCOME","aa","bb","cc","dd","ee","ff","gg");
@endblock

@startblock $AECF "Objects"

	gobject = record
		component0, component1, component2, component3: byte;
		
		// TransformTile
		transX, transY, transZ: byte;
	
		// Render
		rendTilePos: byte;
		
		// Physics
		physGravity: byte;
		b_physFallDown: byte;
		b_physRollLeftRight: byte;

		// ShiftPlattform
		shiftDir: byte;
		
		// Control
		controlId: byte;
		moves: byte;
						
		// Animation
		animId: byte;
		animPos: byte;
		animFinish: byte;

		// Portal
		portalFireExitDir: byte;
		
		// Laser, Fontaine
		laserEmitId: byte;
 		laserTag: byte;
 		
		// Mirror
 		mirrorTurn: byte;
		
		// PushPull  , Door, Exit, Switch
		onOff: byte;
	end;
	objectList : Array[@MAX_OBJECTS] of gobject;
@endblock

@startblock $2000 "Code"

procedure ReadJoySim();
begin
	Key::Read();
	simJoy := 0;
	if ( Key::Held( Key::KW )) then simJoy := simJoy | JOY_UP;
	if ( Key::Held( Key::KS )) then simJoy := simJoy | JOY_DOWN;
	if ( Key::Held( Key::KA )) then simJoy := simJoy | JOY_LEFT;
	if ( Key::Held( Key::KD )) then simJoy := simJoy | JOY_RIGHT;
	if ( Key::Held( Key::KJ )) then simJoy := simJoy | JOY_FIRE;
end;

interrupt vbl();

procedure ColorLine(y: byte, col: byte);
begin
	if(currentBank = 1) then	screenmemory := col1[y] else screenmemory := col2[y];
	fillfast(screenmemory,col,19);
end;

procedure PrintStringColor(p1 : pointer; x, y, c : byte);
var
	len: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 20) then SCREEN_BG_COLOR:=BLUE;
	@ENDIF
	@IFNDEF DEBUG
		len := str::strlen(p1);
		if(currentBank = 1) then	screenmemory := scr1[y] else screenmemory := scr2[y];
		screenmemory := screenmemory + x;
 		printstring(p1,0, len);
		if(currentBank = 1) then	screenmemory := col1[y] else screenmemory := col2[y];
		screenmemory := screenmemory + x;
 		fillfast(screenmemory, c, len);
	@ENDIF		
end;

procedure PrintCenterStringColor(p1 : pointer; y, c : byte);
var
	len,x: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 20) then SCREEN_BG_COLOR:=BLUE;
	@ENDIF
	@IFNDEF DEBUG
		len := str::strlen(p1);
		if(len < 20) then 
			x := 10 - (len / 2)
		else begin 
			x := 0;
		end;
		PrintStringColor(p1, x, y, c);
	@ENDIF		
end;

procedure PrintText(x: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x >= 40) then SCREEN_BG_COLOR:=BLUE;
	@ENDIF
	@IFNDEF DEBUG
		if(currentBank = 1) then	screenmemory := scr1[17] else screenmemory := scr2[17];
		fillfast(screenmemory,$20,20);
		PrintCenterStringColor(sp, 17, WHITE);
	@ENDIF		
end;

procedure PrintFrame();
var
	i: byte;
begin
	if(currentBank = 1) then	screenmemory := scr1[0] else screenmemory := scr2[0];
	fillfast(screenmemory,$1e,19);
	ColorLine(0,@GREEN);
	if(currentBank = 1) then	screenmemory := scr1[13] else screenmemory := scr2[13];
	fillfast(screenmemory,$1f,19);
	ColorLine(13,@GREEN);
end;

procedure ClearText();
begin
	@IFNDEF DEBUG
		if(currentBank = 1) then	screenmemory := scr1[17] else screenmemory := scr2[17];
		fillfast(screenmemory,$20,19);
	@ENDIF
end;

procedure ClearFullScreen();
begin
	clearscreen($20, @SCREEN_ADDR1);  // clear screen
	clearscreen($20, @SCREEN_ADDR2);  // clear screen
	clearscreen($91, @COLOR_ADDR1); // set character colour memory to white
	clearscreen($91, @COLOR_ADDR2); // set character colour memory to white
end;


procedure SwapActiveChar();
begin
	textTimer := 20;
	if(activeChar = 0 and controlList[1].controlState <> @CTRL_STATE_EXITED) then begin 
		activeChar := 1;
		sp :=  #txtCharSwapGreen;
		PrintText(@CHAR_SWAP_GREEN);
	end 
	else if(activeChar = 1 and controlList[0].controlState <> @CTRL_STATE_EXITED) then begin 
		activeChar := 0;
		sp :=  #txtCharSwapRed;
		PrintText(@CHAR_SWAP_RED);
	end;				
end;

procedure LoadFile(addr: integer);
var
	len: byte;
	fn: integer;
begin
    len := str::strlen(fileName);

	asm("
; KERNEL/BASIC ROM Routines

LOAD        = $FFD5
SETLFS      = $FFBA
SETNAM      = $FFBD

main        LDA  #$08            ; Logical file number
            LDX  #$08            ; Device number
            LDY  #$00            ; Secondary address
                                 ; $00 Load using specifed address
                                 ; $01 Load using original address from file
            JSR  SETLFS          ; Set above parameters

            LDA  localVariable_LoadFile_len            ; Length of file name
            LDX  fileName      ; Low byte of file name location
            LDY  fileName+1      ; High byte of file name location
            JSR  SETNAM          ; Set the name

            LDA  #$00            ; Load = 0, Verify = 1
            LDX  localVariable_LoadFile_addr         ; Low byte of start address
            LDY  localVariable_LoadFile_addr+1         ; High byte of start address
            JSR  LOAD            ; Perform load
            BCS  main           ; Jump to error handler if error
	");
end;

procedure InitLevel();
var 
	i : integer;
	levStr: string = "XFF";	
begin
	countObjects := 0;
	countDyn := 0;
	countAnim := 0;
	textTimer := 0;
	countLasers := 0;
	retryPressed := false;
	activeChar := 1;
	statusCol := @BLUE;

	levStr[2] := 0;
	DisableVic20IRQ();
	
	// TODO: new mem pos
	for i:= $AECF to $BFF0 do begin
		sp := int2ptr(i);
		sp[0] := $FF;
	end;
	
	if(gameMode = @MODE_SINGLE) then begin
		AddBreakpoint();
//		if(nextLevel <> levelSingle) then begin
			levelSingle := nextLevel;
			levStr[0] := 'S';
			str::itoa(levelSingle, #levStr+1, 16);
			fileName := #levStr;
			LoadFile($A000);
//		end;
	end
	else begin
		if(gameMode = @MODE_SINGLE_2CHAR) then SwapActiveChar();

//		if(nextLevel <> levelCoop) then begin
			levelCoop := nextLevel;
			levStr[0] := 'M';
			str::itoa(levelCoop, #levStr+1, 16);
			fileName := #levStr[0];
			LoadFile($A000);
			// TODO: Load 
//		end;
	end;
	VIARasterIRQ(vbl(), raster, 0);
end;


procedure SetNextLevel();
begin 
	if(gameMode = @MODE_SINGLE) then begin
		if(levelSingle + 1 >= maxSingleLevels) then nextLevel := 0
		else begin
			nextLevel := levelSingle + 1;
		end;
	end
	else begin
		if(levelCoop +1 >= maxMultiLevels) then nextLevel := 0
		else begin
			nextLevel := levelCoop + 1;
		end;
	end;
end;

procedure IncLevel(mode: byte);
begin 
	if(mode = @MODE_SINGLE) then begin
		if(levelSingle < maxSingleLevels - 1) then inc(levelSingle);
	end
	else begin
		if(levelCoop < maxMultiLevels - 1) then inc(levelCoop);
	end;
end;

procedure DecLevel(mode: byte);
begin 
	if(mode = @MODE_SINGLE) then begin
		if(levelSingle > 0) then dec(levelSingle);
	end
	else begin
		if(levelCoop > 0) then dec(levelCoop);
	end;
end;


procedure InitGame(levSingle, levCoop: byte, mode: byte);
begin
	levelSingle := levSingle;
	levelCoop := levCoop;
	gameMode := mode;
	if(gameMode = @MODE_SINGLE) then nextLevel := levSingle else nextLevel := levCoop;
	menuItem := 0;
	cycle := 0;
	needExtraCycle := false;
end;


procedure print2x2block(x,y,c, col: byte);
begin
	@IFDEF OVERFLOW_CHECK
		if(x = $FF or y = $FF) then SCREEN_BG_COLOR:=WHITE;
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COLOR:=YELLOW;
	@ENDIF
	
	if(currentBank = 1) then	screenmemory := scr1[y+1] else screenmemory := scr2[y+1];
	
	screenmemory[x]:=c;
	if(currentBank = 1) then	screenmemory := col1[y+1] else screenmemory := col2[y+1];
	if(c >= $80) then
		screenmemory[x] := col
	else
		screenmemory[x] := tilesetColors[c];
		
/*
	moveto(x*2,y*2,hi(SCREEN_COL_LOC));
	screenmemory[0]:=tilesetColors[c]+8;
	screenmemory[1]:=tilesetColors[c+1]+8;
	screenmemory[40]:=tilesetColors[c+40]+8;;
	screenmemory[41]:=tilesetColors[c+41]+8;;
	*/
end;
procedure CycleWater();
begin

	asm("
	; scroll vertical body up
	ldy $1bd8+8
	ldx #0
Scroll1tA26758
	lda $1bd9+8,x
	sta $1bd8+8,x
	inx
	cpx #7
	bne Scroll1tA26758
	sty $1bdf+8
	
	
	; scroll vertical body down
	ldy $1be7+8
	ldx #7
Scroll2tA26758
	lda $1be0+7,x
	sta $1be1+7,x
	dex
	cpx #0
	bne Scroll2tA26758
	sty $1be0+8

	; scroll horizontal body right
	ldx #0
RightBitshiftA26758
	lda $1bf0+8,x
	lsr
	ror $1bf0+8,x
	inx
	cpx #8
	bne RightBitshiftA26758
	
	; scroll horizontal body left
	ldx #0
LeftBitshiftA16895
	lda $1be8+8,x
	asl
	rol $1be8+8,x
	inx
	cpx #8
	bne LeftBitshiftA16895
	");

end;

procedure GetZLayerPointer(z: byte);
begin
	case z of
		@Z_BACK2: tempPointer := #mapback2;
		@Z_BACK1: tempPointer := #mapback1;
		@Z_MAIN: tempPointer := #mapmain;
		@Z_FRONT: tempPointer := #mapfront;
	end;
end;

function PaintPosAnim(t: byte, considerAnimation: boolean) : byte;
var
	x,y: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
	
begin
 	animId := objectList[t].animId;
	pa := #animList[animId];
 	if(considerAnimation = true and (objectList[t].component0 & @COMP_ANIMATION_0 = @COMP_ANIMATION_0)) then begin
		if(pa.considerGravity = @ANIM_CONSIDER_GRAV_IGNORE) then shiftAnim := 0
		else if(pa.considerGravity = @ANIM_CONSIDER_GRAV_FULL) then begin
			gravity := @DOWN;
			if((objectList[t].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[t].physGravity;
			if(gravity = @DOWN) then shiftAnim := 0
			else if(gravity = @UP) then shiftAnim := 1
			else if(gravity = @RIGHT) then shiftAnim := 2
			else if(gravity = @LEFT) then shiftAnim := 3;
		end;
		currentTile := pa.animSeq[objectList[t].animPos];
		currentTile := currentTile + shiftAnim;
	
	if(pa.mode = @ANIM_MODE_FIX) then objectList[t].animPos := 0
		else if(pa.mode = @ANIM_MODE_LR and objectList[t].animFinish = false) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := pa.size - 1;
				objectList[t].animFinish := true;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end
		else if(pa.mode = @ANIM_MODE_LR_REPEAT) then begin
			if(objectList[t].animPos = pa.size - 1) then begin
				objectList[t].animPos := 0;
				objectList[t].animFinish := false;
			end
			else if(mod(globaltime, pa.speed) = 0) then inc(objectList[t].animPos);
		end;				
	end
	else currentTile := objectList[t].rendTilePos;
	PaintPosAnim := currentTile;
end;

procedure PaintPos(pos: byte, considerAnimation: boolean, col: byte);
var
	x,y: byte;
	t, tHide: byte;
	animId: byte;
	hideSprite: boolean;
	pa: pointer of animObject;
	currentTile: byte;
	gravity: byte;
	shiftAnim: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COLOR:=WHITE;
	@ENDIF
	
	x := mod(pos,@DIMX);
	y := pos / @DIMX;
	t := $FF;
	currentTile := $FF;

 	if(mapfront[pos] <> 255) then begin
	 	t := mapfront[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end
 	else if(mapmain[pos] <> 255) then begin
	 	t := mapmain[pos];
	 	currentTile := PaintPosAnim(t, true);
 	end
 	else if(mapback1[pos] <> 255) then begin
	 	t := mapback1[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end
	else if(mapback2[pos] <> 255) then begin
	 	t := mapback2[pos];
	 	currentTile := PaintPosAnim(t, considerAnimation);
 	end;
	
	if(t <> $FF) then begin
		print2x2block(x,y,currentTile,col)
	end
	else print2x2block(x,y,$20,$91);
end;

function ConvertShift(gravity: byte, pos: byte) : integer;
var 
    ret: integer;
begin
	@IFDEF OVERFLOW_CHECK
		if(pos >= 9) then SCREEN_BG_COLOR:=RED;
		if(gravity = $FF) then SCREEN_BG_COLOR:=RED;
	@ENDIF
	if(gravity = @DOWN) then ret := CreateInteger(shiftAreaDownX[pos],shiftAreaDownY[pos])
 	else if(gravity = @UP) then ret := CreateInteger(shiftAreaUpX[pos],shiftAreaUpY[pos])
 	else if(gravity = @LEFT) then ret := CreateInteger(shiftAreaLeftX[pos],shiftAreaLeftY[pos])
 	else if(gravity = @RIGHT) then ret := CreateInteger(shiftAreaRightX[pos],shiftAreaRightY[pos]);
    ConvertShift := ret; 	
end;


function CalcPosition(startx,starty, pos: byte) : integer;
var
	destx, desty: byte;
begin
	destx := startx + shiftAreaDownX[pos];
	desty := starty + shiftAreaDownY[pos];
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPosition := CreateInteger(destx, desty); 
end;


function CalcPositionMapPos(startx,starty, pos: byte) : byte;
var 
	npos: integer;
begin
	npos := CalcPosition(startx,starty, pos);
	CalcPositionMapPos := hi(npos) + ystart[lo(npos)];
end;

function GetObjectByPosFilterComp(x: byte, y: byte, z: byte, comp: byte, compIdx: byte) : byte;
var
	mapPos, colId, ret, val: byte;
begin
	GetZLayerPointer(z);
	ret := $FF;
	mapPos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(mapPos >= @DIMTILES) then SCREEN_BG_COLOR:=RED;
	@ENDIF

	colId := tempPointer[mapPos];
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;

	GetObjectByPosFilterComp := ret;
end;

function GetObjArea(id: byte, z: byte, pos:byte, comp: byte, compIdx: byte, b_norm: byte) : byte;
var
	gravity: byte;
	mapPos, colId, ret, val, gpos: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(id >= @MAX_OBJECTS) then SCREEN_BG_COLOR:=WHITE;
	@ENDIF
	gravity := @DOWN;
	if(b_norm = false) then begin
		if((objectList[id].component0 & @COMP_PHYSICS_0) = @COMP_PHYSICS_0) then gravity := objectList[id].physGravity;

		if(objectList[id].physGravity = @DOWN) then gpos := pos
		else if(objectList[id].physGravity = @UP) then gpos := collAreaUp[pos] 
		else if(objectList[id].physGravity = @LEFT) then gpos := collAreaLeft[pos] 
		else if(objectList[id].physGravity = @RIGHT) then gpos := collAreaRight[pos]
	end
	else gpos := pos;

	GetZLayerPointer(z);

	mapPos := CalcPositionMapPos(objectList[id].transX, objectList[id].transY, gpos);
	colId := tempPointer[mapPos];
	ret := $FF;
	if(colId <> $FF) then begin
		case compIdx of
	        0: val := objectList[colId].component0 & comp;
	        1: val := objectList[colId].component1 & comp;
	        2: val := objectList[colId].component2 & comp;
	        3: val := objectList[colId].component3 & comp;
    		end;
		if(val = comp) then ret := colId;
	end;
	GetObjArea := ret;
end;

function CalcPositionX(startx,offsetx: byte) : byte;
var
	destx: byte;
begin
	destx := startx + offsetx;
	if(destx = $FF) then destx := @DIMX - 1
	else if(destx = @DIMX) then destx := 0;
	CalcPositionX := destx;
end;

function CalcPositionY(starty,offsety: byte) : byte;
var
	desty: byte;
begin
	desty := starty + offsety;
	if(desty = $FF) then desty := @DIMY - 1
	else if(desty = @DIMY) then desty := 0;
	CalcPositionY := desty;
end;

procedure ChangeMapItem(id: byte, oldx: byte, oldy: byte, x: byte, y: byte, z:byte);
var
	oldpos: byte;
	pos: byte;
	col: byte;
begin
	oldpos := oldx + ystart[oldy];
	pos := x + ystart[y];
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COLOR:=CYAN;
		if(oldpos >= @DIMTILES) then SCREEN_BG_COLOR:=CYAN;
	@ENDIF
	tempPointer[oldpos] := $FF;
	tempPointer[pos] := id;
	// ##
	if(objectList[id].controlId = 1) then begin
		col := @GREEN;
	end
	else
		col := @WHITE;

	PaintPos(oldpos, true,col);
	PaintPos(pos, true, col);
end;

procedure UpdateMapItem(id: byte, x: byte, y: byte);
var
	oldpos: byte;
	pos: byte;
	col: byte;
begin
	pos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COLOR:=CYAN;
	@ENDIF
	if(objectList[id].controlId = 1) then col := @GREEN else col:= @WHITE;
	
	PaintPos(pos, true,col);
end;

procedure SetPos(i: byte,oldx:byte, oldy:byte, x: byte, y: byte, z: byte);
var
	pos: byte;
	waypointId, lastWaypointId, controlId: byte;
begin
	@IFDEF OVERFLOW_CHECK
		if(i >= @MAX_OBJECTS) then SCREEN_BG_COLOR:=CYAN;
	@ENDIF
	pos := x + ystart[y];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COLOR:=CYAN;
	@ENDIF
	controlId := objectList[i].controlId;
	inc(objectList[i].moves); 

	if(controlId <> $FF) then begin
		waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(waypointId = $FF) then
			waypointId := GetObjectByPosFilterComp(x, y, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK1, @COMP_WAYPOINT_3, 3);
		if(lastWaypointId = $FF) then
			lastWaypointId := GetObjectByPosFilterComp(oldx, oldy, @Z_BACK2, @COMP_WAYPOINT_3, 3);
		controlList[controlId].waypointId := waypointId;
		controlList[controlId].lastWaypointId := lastWaypointId;
	end;
	
	ChangeMapItem(i, oldx, oldy, x, y, z);
	objectList[i].transX := x;
	objectList[i].transY := y;
end;

procedure SetZLayer(id: byte, oldz: byte, newz: byte);
var
	pos: byte;
begin
	pos := objectList[id].transX + ystart[objectList[id].transY];
	@IFDEF OVERFLOW_CHECK
		if(pos >= @DIMTILES) then SCREEN_BG_COLOR:=CYAN;
	@ENDIF
	inc(objectList[id].moves); 
	GetZLayerPointer(oldz);
	tempPointer[pos] := $FF;
	GetZLayerPointer(newz);
	tempPointer[pos] := id;
	objectList[id].transZ := newz;
	PaintPos(pos, true,$91);
end;

procedure AddMapItem(Id: byte, x: byte, y: byte, z:byte);
var
	pos: byte;
begin
	pos := x + ystart[y];
	GetZLayerPointer(z);
	@IFDEF OVERFLOW_CHECK
		if(x = @DIMX or y = @DIMY) then SCREEN_BG_COLOR:=YELLOW;
	@ENDIF
	
	tempPointer[pos] := Id;
end;

procedure ClearMap();
var 
	m: byte;
begin
    for m := 0 to @DIMTILES do	
	begin
 	 	mapback2[m] := 255;
 	 	mapback1[m] := 255;
 	 	mapmain[m] := 255;
 	 	mapfront[m] := 255;
 	end;
	portals[0] := $FF;
	portals[1] := $FF;
end;

procedure AddDynItem(i: byte);
begin
	dynObjectList[countDyn] := i;
	inc(countDyn);
end;

procedure AddAnimItem(i: byte);
begin
	animObjectList[countAnim] := i;
	inc(countAnim);
end;
function GetId() : byte;
var
	ret: byte;
begin
    if (countObjects = @MAX_OBJECTS) then	 begin 
		ret := $FF;
	end
    	else begin	
		inc(countObjects);
		ret := deletedObjects[@MAX_OBJECTS - 1 - countObjects];
	end;

	GetId := ret;
end;

function GetLaserEmitId() : byte;
var
	ret: byte;
begin
    if (countLasers = @MAX_LASERS) then	 ret := $FF
    	else begin	
		inc(countLasers);
		ret := countLasers;
	end;

	GetLaserEmitId := ret;
end;

procedure PaintFull();
var
	i: byte;
begin
    for i := 0 to @DIMTILES do
	begin
		PaintPos(i, false,$91);
	end;
end;

procedure DeleteMapItem(id: byte, x: byte, y: byte, z:byte);
var	
	pos: byte;
begin
	pos := x + ystart[y];	
	GetZLayerPointer(z); 
	tempPointer[pos] := 255;
end;

procedure DeleteDynObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countDyn - 1 and found = false)  do
	begin
		if(dynObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countDyn); 
		for j:= i to countDyn do begin
			dynObjectList[j] := dynObjectList[j+1];
		end;
	end;
end;

procedure DeleteAnimObject(id: byte);
var	
	i,j: byte;	
	found: boolean;
begin
	i := 0;
	found := false;
	while (i < countAnim - 1 and found = false) do
	begin
		if(animObjectList[i] = id) then 
			found := true
		else
			inc(i);
	end;
	if(found = true) then begin
		dec(countAnim); 
		for j:= i to countAnim do begin
			animObjectList[j] := animObjectList[j+1];
		end;
	end;
end;
	
procedure DeletePos(id: byte, isDyn, isAnim: byte);
var
	x,y: byte;
begin
	if(countObjects > 0) then begin
		deletedObjects[@MAX_OBJECTS - 1 - countObjects] := id;
		dec(countObjects);
		DeleteMapItem(id, objectList[id].transX, objectList[id].transY, objectList[id].transZ);
		if(isDyn = true) then begin
			DeleteDynObject(id); 
			PaintPos(objectList[id].transX + ystart[objectList[id].transY], true, $91);
		end;

		if(isAnim = true) then DeleteAnimObject(id);
		PaintPos(objectList[id].transX + ystart[objectList[id].transY], true,$91);
	end; 
end;	

procedure SwitchBank();
begin
	if (currentBank = 0) then 
	begin
		VICCR5 := $fe;
		VICCR2 := VICCR2 | $80;		
		currentBank := 1;
	end
	else 
	begin
		VICCR5 := $ce;
		VICCR2 := VICCR2 & $7F;		
		currentBank := 0;
	end;
end;

procedure CycleAnimation(id: byte);
var
	animId: byte;
	pa: pointer of animObject;

begin
 	animId := objectList[id].animId;
	pa := #animList[animId];
	if(objectList[id].animPos = pa.size - 1) then begin
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end
	else if(mod(globaltime, pa.speed) = 0) then inc(objectList[id].animPos);
end;

procedure SwitchAnimation(id: byte, anim: byte); 
begin
	if(objectList[id].animId <> anim) then begin
		objectList[id].animId := anim;
		objectList[id].animPos := 0;
		objectList[id].animFinish := false;
	end;
end;

procedure ClearLaserWithTag(tag: byte);
var
	i,c: byte;
	d: byte;
begin
	for i:= 0 to @DIMTILES do begin
		
		c := mapfront[i];
		if(c <> $FF and objectList[c].laserTag = tag) then begin
			if(objectList[c].component2 & @COMP_LASERBEAN_2 = @COMP_LASERBEAN_2) then begin 
				DeletePos(c, false, false);
			end;
		end;
/*		c := mapback2[i];
		if(c <> $FF and (objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
		*/
	end;
end;


procedure ClearAllLaser();
var
	i,c: byte;
	d: byte;
begin
	for i:= 0 to @DIMTILES do begin
		
		c := mapfront[i];
		if(c <> $FF and objectList[c].laserTag <> $FF) then begin
			if(objectList[c].component2 & @COMP_LASERBEAN_2 = @COMP_LASERBEAN_2 or objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0) then begin 
				DeletePos(c, false, false);
			end;
		end;
		c := mapback2[i];
		if(c <> $FF and (objectList[c].component0 & @COMP_WATER_0 = @COMP_WATER_0 and objectList[c].laserTag <> $FF)) then begin 
			DeletePos(c, false, false);
		end;
	end;
end;

procedure DirectFire(id: byte, xpos, ypos: byte, xdir, ydir: byte, bomb: boolean);
var
	laserEmitId: byte;
	laserId: byte;
	collideId, floaterId: byte;
	collide: boolean;
	laserx, lasery, lastx, lasty: byte;
	countLaser: byte;
	dir: byte;
	tileUp, tileDown, tileLeft, tileRight, z, comp0, comp2: byte;
begin	
	if(objectList[id].onOff = @ON) then begin
		laserEmitId := objectList[id].laserEmitId;
		if(bomb = true) then begin
			tileLeft := $58;
			tileRight := $58;
			tileUp := $59;
			tileDown := $59;
			z := @Z_FRONT;
			comp0 := $00 | @COMP_COLLIDE_ABLE_0;
			comp2 := $00 | @COMP_LASERBEAN_2;
		end
		else begin
			tileLeft := $7e;
			tileRight := $7f;
			tileUp := $7c;
			tileDown := $7d;
			z:= @Z_BACK2;
			comp0 := $00 | @COMP_COLLIDE_ABLE_0 | @COMP_WATER_0;
			comp2 := $00;
		end;
			
		collide := false;
		lastx := xpos;
		lasty := ypos;
		laserx := CalcPositionX(xpos, xdir);
		lasery := CalcPositionY(ypos, ydir);
		countLaser := 0;
		collideId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_COLLIDE_ABLE_0, 0);
		floaterId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_FLOATER_1, 1);
		if (collideId <> $FF and floaterId = $FF) then collide := true;
		while (collide = false and countLaser < laserList[laserEmitId].currentLaser) do begin
			collideId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_COLLIDE_ABLE_0, 0);
			floaterId := GetObjectByPosFilterComp(laserx, lasery, @Z_MAIN, @COMP_FLOATER_1, 1);
			if (collideId <> $FF and floaterId = $FF) then begin
				collide := true;
			end
			else begin
				
				if ((mapback2[laserx + ystart[lasery]] = $FF and bomb = false) or (mapfront[laserx + ystart[lasery]] = $FF and bomb = true)) then begin
					laserId := GetId();
					if(laserId <> $FF) then begin				
						if (xdir = -1 and ydir = 0) then begin 
							objectList[laserId].rendTilePos := tileLeft;
							objectList[laserId].physGravity := @LEFT;
						end
						else if (xdir = 1 and ydir = 0) then begin
							objectList[laserId].rendTilePos := tileRight;
							objectList[laserId].physGravity := @RIGHT;
						end
						else if (xdir = 0 and ydir = -1) then begin
						    objectList[laserId].rendTilePos := tileUp;
							objectList[laserId].physGravity := @UP;
						end
						else if (xdir = 0 and ydir = 1) then begin
							objectList[laserId].rendTilePos := tileDown;
							objectList[laserId].physGravity := @DOWN;
						end;
						objectList[laserId].component0 := comp0;
						objectList[laserId].component1 := $00;
						objectList[laserId].component2 := comp2;
						objectList[laserId].component3 := $00;
						objectList[laserId].transX := laserx;
						objectList[laserId].transY := lasery;
						objectList[laserId].transZ := z;
						objectList[laserId].laserTag := id;
						AddMapItem(laserId, laserx, lasery, z);
						PaintPos(laserx + ystart[lasery], false,$91);
					end;
				end;
				lastx := laserx;
				lasty := lasery;
				laserx := CalcPositionX(laserx, xdir);
				lasery := CalcPositionY(lasery, ydir);
				inc(countLaser);
			end;
		end;
	end;
end;

procedure Animate();
var 
	i: byte;
	id: byte;
begin
	if(countAnim <> 0) then begin
		for i:=0 to countAnim do	begin
			id := animObjectList[i];
			UpdateMapItem(id, objectList[id].transX, objectList[id].transY); 
		end;
	end;
end;


@include "Sounds.ras"
procedure DecreaseTextTimer();
begin
	if(textTimer > 0) then begin
		dec(textTimer);
		if(textTimer = 0) then ClearText();
	end; 
end;

function Pos2ObjectId(pos: byte) : byte;
var
	c: byte;
begin
	c := $FF;
	if(pos <> $FF) then begin
		if(mapback2[pos] <> $FF) then c := mapback2[pos]
		else if(mapback1[pos] <> $FF ) then c := mapback1[pos]
		else if(mapmain[pos] <> $FF) then c := mapmain[pos]
		else if(mapfront[pos] <> $FF) then c := mapfront[pos];
	end;
	Pos2ObjectId := c;
end; 


procedure InitActors();
var
	i,j,x,y,c : byte;
begin
	j := 0;
	for i := 0 to @MAX_ACTORS * @ACTOR_LENGTH step @ACTOR_LENGTH do
	begin
		actorList[j].event := levActor[i];
		actorList[j].action := levActor[i+1];
		actorList[j].senderId := Pos2ObjectId(levActor[i+2]);   
		actorList[j].receiverId := Pos2ObjectId(levActor[i+3]);
		actorList[j].param0 := levActor[i+4];
		actorList[j].param1 := levActor[i+5];
		actorList[j].param2 := levActor[i+6];
		actorList[j].param3 := levActor[i+7];
		inc(j);
	end;
end;


procedure MenuMove(len: byte, oldMenuItem: byte);
var 
	col: byte;
begin
		if(joy1 & JOY_UP = JOY_UP) then begin
			if(menuItem > 0) then dec(menuItem);
		end
		else if(joy1 & JOY_DOWN = JOY_DOWN) then begin
			if(menuItem < len-1 ) then inc(menuItem); 
	end;
	ColorLine(12 + oldMenuItem, @WHITE);
	if(mod(globaltime, 4) < 2) then col := @BLUE else col := @CYAN;
	ColorLine(12 + menuItem, col);
end;
// @include "Sounds.ras"

@include "Actions.ras"
@include "GObjects.ras"
@include "ControlComponent.ras"
@include "PhysComponent.ras"
@include "FloaterComponent.ras"
@include "FontaineComponent.ras"
@include "LaserComponent.ras"

procedure UpdateObject(id: byte);
var
	controlId: byte;
begin
	if(objectList[id].component1 & @COMP_LASER_1 = @COMP_LASER_1) then begin 
		UpdateLaser(id);
	end;
	if(objectList[id].component2 & @COMP_FONTAINE_2 = @COMP_FONTAINE_2) then begin 
		UpdateFontaine(id);
	end;
		
	if(cycle = 0) then begin
		if(objectList[id].component0 & @COMP_PHYSICS_0 = @COMP_PHYSICS_0) then begin
			UpdatePhysics(id);
			ProcessBackObj(id);
		end;
		if(objectList[id].component1 & @COMP_FLOATER_1 = @COMP_FLOATER_1) then begin 
			UpdateFloater(id);
			ProcessBackObj(id);
		end;
		
		if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin
			controlId := objectList[id].controlId;
			if(objectList[id].moves > 0 and controlList[controlId].b_fallDown = false) then needExtraCycle := true
			else begin
				if(retryPressed = true and controlList[controlId].controlState <> @CTRL_STATE_DESTROY) then begin
					@PLAY_SOUND("3","sndExplosion","200")
					objectList[id].b_physFallDown := false;
					controlList[controlId].controlState := @CTRL_STATE_DESTROY;
					controlList[controlId].controlJumpStep := 0;
		//			retryPressed := $FF;
		 		end;
				//ProcessDestroyObj(id);
				InputControl(id); 
				UpdateControl(id);
				ProcessBackObj(id);
		 	end;
		end;
	end
	else begin	
		if(objectList[id].component0 & @COMP_CONTROL_0 = @COMP_CONTROL_0) then begin
			controlId := objectList[id].controlId;
			if(retryPressed = true and controlList[controlId].controlState <> @CTRL_STATE_DESTROY) then begin
				@PLAY_SOUND("3","sndExplosion","200")
				objectList[id].b_physFallDown := false;
				controlList[controlId].controlState := @CTRL_STATE_DESTROY;
				controlList[controlId].controlJumpStep := 0;
	//			retryPressed := $FF;
	 		end;
			//ProcessDestroyObj(id);
			InputControl(id); 
			UpdateControl(id);
			ProcessBackObj(id);
		end;
	end;
		objectList[id].moves := 0;
end;

procedure Update();
var 
	i: byte;
	id: byte;
begin
	ClearAllLaser();
	i := getkey();
	if(gameMode = @MODE_SINGLE_2CHAR) then begin
		//Key::Read();
		if (i = KEY_SPACE) then begin
			@PLAY_SOUND("2","sndPlayerChange","240")
			SwapActiveChar();
		end;
	end;
	if (i = KEY_F7) then begin
		retryPressed := true;
	end; 
	if(cycle = 0 and needExtraCycle = true) then cycle := 1 else cycle := 0;

	for i:=0 to countDyn do	begin
		id := dynObjectList[i];
		UpdateObject(id);
	end;
	
	if(cycle = 1) then needExtraCycle := false;
	
end;



procedure InitAnimations();
var
	pa: pointer of animObject;

begin
	// walk left
	// l            r            u            d
	// 00 01 02 03  04 05 06 07  08 09 0a 0b  0c 0d 0e 0f 

	// walk right
	// l            r            u            d
	// 10 11 12 13  14 15 16 17  18 19 1a 1b  1c 1d 1e 1f 

	// stand
	// l  r  u  d
	// 20 21 22 23
	
	// swim l
	// l     r     u     d
	// 24 25 26 27 24 25 26 27

	// swim r
	// l     r     u     d
	// 28 29 2a 2b 28 29 2a 2b

	// TODO	
	// climb
	// l     r     u     d
	// 2c 2d 2e 2f 30 31 32 33

	// TODO	
	// robe
	// l     r     u     d
	// 34 35 36 37 48 49 4a 4b

 
	
	pa := #animList[@ANIM_WALK_L];
	pa.animSeq[0] := $80;
	pa.animSeq[1] := $84;
	pa.animSeq[2] := $88;
	pa.animSeq[3] := $8c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_WALK_R];
	pa.animSeq[0] := $90;
 	pa.animSeq[1] := $94;
	pa.animSeq[2] := $98;
	pa.animSeq[3] := $9c;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_STAND];
	pa.animSeq[0] := $a0; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_L];
	pa.animSeq[0] := $a4; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_SWIM_R];
	pa.animSeq[0] := $a8; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;

	pa := #animList[@ANIM_CLIMB];
	pa.animSeq[0] := $ac; 
 	pa.animSeq[1] := $b0;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_ROBE];
	pa.animSeq[0] := $b4; 
 	pa.animSeq[1] := $b8;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_FULL;
	pa.size := 2;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_MANUAL;

	pa := #animList[@ANIM_PORTAL];
	pa.animSeq[0] := $6b; 
 	pa.animSeq[1] := $6c;
	pa.animSeq[2] := $6d;
	pa.animSeq[3] := $6e;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_LR_REPEAT;

	pa := #animList[@ANIM_SWITCH_ON];
	pa.animSeq[0] := $63; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_SWITCH_OFF];
	pa.animSeq[0] := $64; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_DOOR_ON];
	pa.animSeq[0] := $67; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	
	
	pa := #animList[@ANIM_DOOR_OFF];
	pa.animSeq[0] := $66; 
 	pa.animSeq[1] := $FF;
	pa.animSeq[2] := $FF;
	pa.animSeq[3] := $FF;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 1;
	pa.speed := 1;
	pa.mode := @ANIM_MODE_FIX;	

	pa := #animList[@ANIM_EXIT_ON];
	pa.animSeq[0] := $4f; 
 	pa.animSeq[1] := $4f;
	pa.animSeq[2] := $50;
	pa.animSeq[3] := $51;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	

	pa := #animList[@ANIM_EXIT_OFF];
	pa.animSeq[0] := $51; 
 	pa.animSeq[1] := $50;
	pa.animSeq[2] := $4f;
	pa.animSeq[3] := $4f;
	pa.considerGravity := @ANIM_CONSIDER_GRAV_IGNORE;
	pa.size := 4;
	pa.speed := 4;
	pa.mode := @ANIM_MODE_LR;	
	

end;
procedure InitialiseTables();
begin
	// create an address table of screen row addresses, we will use this to quickly find the Y position in screen memory
	// without needing to use costly multiplication
	createaddresstable(#scr1, @SCREEN_ADDR1, @SCREEN_WIDTH, @SCREEN_HEIGHT);
	createaddresstable(#scr2, @SCREEN_ADDR2, @SCREEN_WIDTH, @SCREEN_HEIGHT);
	createaddresstable(#col1, @COLOR_ADDR1, @SCREEN_WIDTH, @SCREEN_HEIGHT);
	createaddresstable(#col2, @COLOR_ADDR2, @SCREEN_WIDTH, @SCREEN_HEIGHT);
end;

procedure InitScreen();
begin
	// set the screen and border colour
	SCREEN_TEXT_WIDTH := @SCREEN_WIDTH | 128;  // width
	SCREEN_TEXT_HEIGHT := 38; // 24 (25 rows-1) x 2
	HSCROLL_REGISTER := peek(HSCROLL_REGISTER, 0) + 2;
	VSCROLL_REGISTER := peek(VSCROLL_REGISTER, 0) + 2;

	definescreen();	
	
//	SCREEN_BG_COLOR := %00001110;
	SCREEN_BG_COLOR := %00001000;
	VICCR5 := $ce;
	VICCR2 := VICCR2 & $7F;		
	InitialiseTables();
end;

@endblock
@startblock "$A280" code

procedure UpdateMain();
var
	levStr: string="00";
	levStr2: string="00";
	pos : byte;
	len: byte;
begin	
	if(state = @STATE_MENU_INPUT) then begin
		if(levelSingle >= 9) then pos := 0 else pos := 1; 
		str::itoa(levelSingle + 1, #levStr + pos, 10);
		if(levelCoop >= 9) then pos := 0 else pos := 1; 
		str::itoa(levelCoop + 1, #levStr2 + pos, 10); 
		
		if(joy1 & JOY_FIRE = JOY_FIRE) then begin
			if(menuItem = 0 or menuItem = 3) then InitGame(levelSingle, levelCoop, @MODE_SINGLE);
			if(menuItem = 1) then InitGame(levelSingle, levelCoop, @MODE_SINGLE_2CHAR);
			if(menuItem = 2 or menuItem = 4) then InitGame(levelSingle, levelCoop, @MODE_COOP);
			state := @STATE_OPEN_SCENE; //TODO
		end;
		if(joy1 & JOY_LEFT = JOY_LEFT) then begin
			if(menuItem = 3) then DecLevel(@MODE_SINGLE);
			if(menuItem = 4) then DecLevel(@MODE_COOP);
		end;
		if(joy1 & JOY_RIGHT = JOY_RIGHT) then begin
			if(menuItem = 3) then IncLevel(@MODE_SINGLE);
			if(menuItem = 4) then IncLevel(@MODE_COOP);
		end;
		
		PrintStringColor(#levStr,17,15,@WHITE);
		PrintStringColor(#levStr2,17,16,@WHITE);
		
		MenuMove(5, menuItem);
	end
	
	else if(state = @STATE_OPEN_SCENE_INPUT) then begin
		if(joy1 & JOY_FIRE = JOY_FIRE) then begin
			if(menuItem = 0) then state := @STATE_INIT
			else if(menuItem = 1) then state := @STATE_MENU;
		end; 
		MenuMove(2, menuItem);
	end;
end;

procedure OpenMain();
var
	i: byte;
	levStr: string = "00";
	pos : byte;
	len: byte;
	
begin	
	time := 0;
	menuItem := 0;
	levStr[0] := '0';
	if(state = @STATE_OPEN_SCENE) then begin 
//		InitLevel();
		if(gameMode = @MODE_SINGLE) then begin
			if(levelSingle >= 9) then pos := 0 else pos := 1; 
			str::itoa(levelSingle + 1, #levStr + pos, 10)
		end
		else begin
			if(levelCoop >= 9) then pos := 0 else pos := 1; 
			str::itoa(levelCoop + 1, #levStr + pos, 10)
		end;
		PrintCenterStringColor(#txtLevel, 4, @GREEN);
		PrintStringColor(#levStr, 13, 4, @GREEN);

				
		PrintCenterStringColor(levStrings[0], 6, @YELLOW);

		if(gameMode <> @MODE_SINGLE) then begin
			if(levBothMustComplete = true) then PrintCenterStringColor(#txtBothMustComplete,8,@YELLOW) 
			else PrintCenterStringColor(#txtOneMustComplete,8,@YELLOW);
		end;

		PrintCenterStringColor(#txtStartLevel, 12, @WHITE);
		PrintCenterStringColor(#txtMainMenu, 13, @WHITE);
	
		PrintCenterStringColor(#txtPressDel, 16, @CYAN);
		@PLAY_SOUND("1","sndEnd","240")
		if(gameMode = @MODE_SINGLE_2CHAR) then PrintCenterStringColor(#txtPressSpace,17,@CYAN);
		if(gameMode = @MODE_COOP) then PrintCenterStringColor(#txtPressWasd,17,@CYAN);
		
		state := @STATE_OPEN_SCENE_INPUT;
	end
	else if(state = @STATE_MENU) then begin
		
		PrintCenterStringColor(#txtLogo,3,@YELLOW);

//		PrintCenterStringColor(#txtSelectGameMode,9,@GREEN);
		
//		PrintCenterStringColor(#txtSelectGameMode,9,@GREEN);

		PrintCenterStringColor(#txtSinglePlayer,12,@WHITE);
		PrintCenterStringColor(#txtSinglePlayer2Chars,13,@WHITE);
		PrintCenterStringColor(#txtCoop,14,@WHITE);

		PrintCenterStringColor(#txtSingleStart,15,@WHITE);
		PrintCenterStringColor(#txtCoopStart,16,@WHITE);
		
		PrintCenterStringColor(#txtAuthor,18,@CYAN);
	
		state := @STATE_MENU_INPUT;
	end;

end;

procedure InitMap();
var 
	i,x,y,c : byte;
begin
	ClearMap();
	countDyn := 0;
	countAnim := 0;

	for i:= 0 to @MAX_OBJECTS do begin
		deletedObjects[@MAX_OBJECTS - 1 - i] := i;
	end;	
	for i := 0 to @DIMTILES do
	begin
		c := lev[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_FONTAINE_DOWN: InitFontaine(x,y, $71, @DOWN);
			@LEV_FONTAINE_UP: InitFontaine(x,y,$70,@UP);
			@LEV_FONTAINE_LEFT: InitFontaine(x,y, $72, @LEFT);
			@LEV_FONTAINE_RIGHT: InitFontaine(x,y,$73,@RIGHT);
			@LEV_CANNON_DOWN: InitCannon(x,y, $47, @DOWN);
			@LEV_CANNON_UP: InitCannon(x,y,$46,@UP);
			@LEV_CANNON_LEFT: InitCannon(x,y, $48, @LEFT);
			@LEV_CANNON_RIGHT: InitCannon(x,y,$49,@RIGHT);
		end;
	end;	
	
	for i := 0 to @DIMTILES do
	begin
		c := lev[i];
		x := mod(i,@DIMX);
		y := i / @DIMX;
		case c of
			@LEV_CHARACTER: InitCharacter(x,y,0);
			@LEV_CHARACTER2: begin
				if(gameMode = @MODE_SINGLE_2CHAR or gameMode = @MODE_COOP) then InitCharacter(x,y,1);
			end;
			@LEV_BRICK: InitBrick(x, y);
			@LEV_STONE: InitStone($41, x, y, true);
			@LEV_BLOCK: InitStone($65, x, y, false);
			@LEV_WATER: InitWater(x, y);
			@LEV_WATER_UP: InitWaterFlow(x, y, $7c, @UP);
			@LEV_WATER_DOWN: InitWaterFlow(x, y, $7d, @DOWN);
			@LEV_WATER_LEFT: InitWaterFlow(x, y, $7e, @LEFT);
			@LEV_WATER_RIGHT: InitWaterFlow(x, y, $7f, @RIGHT);
			@LEV_SAND: InitSand(x, y);
			@LEV_SHIFT_UP: InitShiftPlattform(x, y,$42,@UP);
			@LEV_SHIFT_DOWN: InitShiftPlattform(x, y,$43,@DOWN);
			@LEV_SHIFT_RIGHT: InitShiftPlattform(x, y, $45,@RIGHT);
			@LEV_SHIFT_LEFT: InitShiftPlattform(x, y, $44,@LEFT);
			@LEV_LADDER: InitLadder(x,y);
			@LEV_ROBE_UP: InitRobe(x,y,$5e,@DOWN);
			@LEV_ROBE_DOWN: InitRobe(x,y,$5f,@UP);
			@LEV_ROBE_LEFT: InitRobe(x,y,$60,@LEFT);
			@LEV_ROBE_RIGHT: InitRobe(x,y,$61,@RIGHT);
			@LEV_PORTAL: InitPortal(x,y,@UP);
			@LEV_PORTAL_ACTIVATE: InitPortalActivate(x,y);
			@LEV_GRAVPAD_UP: InitGravPad(x,y,$53,@UP);
			@LEV_GRAVPAD_DOWN: InitGravPad(x,y,$54,@DOWN);
			@LEV_GRAVPAD_LEFT: InitGravPad(x,y,$56,@LEFT);
			@LEV_GRAVPAD_RIGHT: InitGravPad(x,y,$55,@RIGHT);
			@LEV_MIRROR_LEFT: InitMirror(x,y, $5c, @TURN_LEFT);
			@LEV_MIRROR_RIGHT: InitMirror(x,y, $5d, @TURN_RIGHT);
			@LEV_GLASS: InitMirror(x,y,$52, @TURN_THROUGH);
			@LEV_LASER_TRANSPORT: InitLaserTransport(x,y);
//			@LEV_LASER_TRANSPORT_ONCE: InitLaserTransportOnce(x,y);
			@LEV_PUSH_BOX: InitBox(x,y, $69 , 1);
			@LEV_PULL_BOX: InitBox(x,y, $6a , -1);
			@LEV_SWITCH_MANUAL: InitSwitchManual(x,y);
			@LEV_DOOR: InitDoor(x,y);
			@LEV_EXIT: InitExit(x,y);
			@LEV_WAYPOINT: InitWaypoint(x,y);
		end;
	end;
end;



procedure LoopMenu();
begin
	while(state = @STATE_MENU_INPUT or state = @STATE_OPEN_SCENE_INPUT) do begin
		ReadJoy1();
		waitnoraster(0);
		if(frameStatus = 0)	then begin
			UpdateMain();
			frameStatus := 1;
			inc(globaltime);	
		end;	
	end;				
end;

procedure LoopMenu1();
var 
	exitOpen: boolean;
begin
	ClearFullScreen();  // clear screen
	exitOpen := false;
	frameStatus := 1;
	while(exitOpen = false) do begin
		//waitnoraster(0);
		if(frameStatus = 0)	then begin
			OpenMain();
			frameStatus := 1;
			exitOpen := true;
		end;					
	end;
end;

procedure InitScene();

procedure GameLoop();
begin
	While(true) do begin
		ReadJoy1();
		
		waitnoraster(0);
		case state of
			@STATE_MENU: 
				LoopMenu1();	
			@STATE_OPEN_SCENE: begin
				ClearFullScreen();
				InitLevel();
				LoopMenu1();	
			end;
			@STATE_MENU_INPUT:
				LoopMenu();
			@STATE_OPEN_SCENE_INPUT: begin
				LoopMenu();
			end;
			@STATE_INIT: InitScene();
			@STATE_PLAY: begin
			
				frameStatus := 1; // will be updated in raster chain
				time := 0;
				while(state = @STATE_PLAY) do begin
					ReadJoy1();
					ReadJoySim();
					waitnoraster(0);
					if(frameStatus = 0)	then begin
						Update();
						Animate();
						CycleWater();
						DecreaseTextTimer();
						frameStatus := 1;
						inc(globaltime);	
					end;					
				end;
			end;
		end;
	end;	
end;


@endblock


interrupt vbl();
begin
	StartIRQ(0);
	UpdateSound();
	if(frameStatus = 1) then begin
		if(time = 0) then begin
			SwitchBank();
			// if(state = @STATE_OPEN_SCENE_REQUEST) then state := @STATE_OPEN_SCENE;

		end
		else if(time = 1 and currentBank = 0) then begin 
			copyHalfScreen(^@SCREEN_ADDR1, ^@SCREEN_ADDR2, 10,0,0);
			copyHalfScreen(^@COLOR_ADDR1, ^@COLOR_ADDR2, 10,0,0);
		end
		else if(time = 1 and currentBank = 1) then begin
			copyHalfScreen(^@SCREEN_ADDR2, ^@SCREEN_ADDR1, 10,0,0);
			copyHalfScreen(^@COLOR_ADDR2, ^@COLOR_ADDR1, 10,0,0);
		end;
	end;
	if(time = 2) then begin
      	frameStatus := 0;
    end;
    if(time < 4) then inc(time)
	else if(frameStatus = 1) then begin 
		time:=0;
	end;
    closeIRQ();
end;


procedure InitScene();
begin

	InitMap();
	InitActors();
	DisableVIC20IRQ();	
	ClearFullScreen();  // clear screen
	PaintFull();
	PrintFrame();
	ClearText();
	SwitchBank;
	ClearFullScreen();  // clear screen
	PaintFull();
	PrintFrame();
	ClearText();
	
	InitAnimations();
	state := @STATE_PLAY;
	@PLAY_SOUND("2","sndSceneStart","240")
	
	VIARasterIRQ(vbl(), raster, 0);
	DispatchEvent(@EVENT_INIT_LEVEL, $FF, $FF, $FF);
end;

begin
	if (HSCROLL_REGISTER = 12) then raster := 121 else raster := 107;
	ClearFullScreen();  // clear screen
	fileName := "VAR";
	LoadFile($0400);
	fileName := "COD";
	LoadFile($A000);
	DisableVic20IRQ();
	InitScreen();
	SetupSound();
	
	ClearFullScreen();  // clear screen
	
	maxSingleLevels := 48;
	maxMultiLevels := 30;
	InitGame(0, 0, @MODE_COOP);
	state := @STATE_MENU;

	VIARasterIRQ(vbl(), raster, 0);
	/*
	@define SOUND_TRANSPORT 18 //x	 // ->19
	@define SOUND_DAMAGE 7 //x
	@define SOUND_LASER 11 //x
	@define SOUND_JUMP 3 //xe
	@define SOUND_STEP 8 //x
	@define SOUND_SWIM 9 // x ->1
	@define SOUND_GRAV_ACTIVATE 10 // x->15
	@define SOUND_SWITCH_ON 4 //x ->16
	@define SOUND_SWITCH_OFF 5 //x
	@define SOUND_FALL_CRASH 17 // x
	@define SOUND_FALL 2 //x
	@define SOUND_SHIFT 13 //x 
	@define SOUND_LADDER 0 //x
	@define SOUND_SCENE_START 6 //x
	@define SOUND_END 16
	@define SOUND_PLAYER_CHANGE 12 //x
	@define SOUND_PORTAL_ACTIVATE 20 //x 
	@define SOUND_PORTAL 21 // x
	@define SOUND_EXIT 22 //x
	@define SOUND_EXIT_CLOSE 23 //x 

	
	while(true) do begin
		waitforraster(0);
		frameStatus := 1;
		inc(globaltime);
		i := getkey();
		if (i = KEY_F1) then begin 
			@PLAY_SOUND("3","sndStep","150")
		end; 
		if (i = KEY_F3) then begin
			@PLAY_SOUND("3","sndFall","240")
		end; 
		if (i = KEY_F5) then begin
			@PLAY_SOUND("3","sndFall","240")
		end; 
		if (i = KEY_F7) then begin
			@PLAY_SOUND("3","sndExit","240")
 		end; 
		if (i = KEY_A) then begin
			@PLAY_SOUND("0","sndSwim","240")
		end; 
		if (i = KEY_B) then begin
			@PLAY_SOUND("3","sndGravActivate","240")
		end; 
		if (i = KEY_C) then begin
			@PLAY_SOUND("3","sndPlayerChange","240")
 		end; 
		if (i = KEY_D) then begin
			@PLAY_SOUND("3","sndSwitchOn","240")
		end; 
		if (i = KEY_E) then begin
			@PLAY_SOUND("3","sndSwitchOff","240")
		end;
		if(i = KEY_F) then begin
			@PLAY_SOUND("3","sndExitClose","240")
		end;
		if(i = KEY_G) then begin
			@PLAY_SOUND("3","sndEnd","240")
		end;


		

	end;
	*/
    GameLoop(); 
	Loop();
end.